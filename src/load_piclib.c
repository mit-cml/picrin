/**
 *                                !!NOTICE!!
 * This file was automatically generated by mkloader.pl, and includes all of
 * the prelude files required by Picrin. PLEASE DO NOT EDIT THIS FILE, changes
 * will be overwritten the next time the script runs.
 */

#include "picrin.h"
#include "picrin/extra.h"

static const char piclib_src_contrib_10_attribute_attr[][80] = {
"(define-library (picrin base)\n\n  (define attribute-table (make-ephemeron))\n\n  (d",
"efine (attribute obj)\n    (let ((r (attribute-table obj)))\n      (if r\n         ",
" (cdr r)\n          (let ((dict (make-dictionary)))\n            (attribute-table ",
"obj dict)\n            dict))))\n\n  (export attribute))\n",
"",
};

static const char piclib_src_contrib_10_macro_macro[][80] = {
"(define-library (picrin macro)\n  (import (picrin base))\n\n  ;; macro primitives\n\n",
"  (export define-macro\n          make-identifier\n          identifier?\n         ",
" identifier=?\n          identifier-base\n          identifier-environment)\n\n  ;; ",
"simple macro\n\n  (export define-syntax\n          syntax-quote\n          syntax-qu",
"asiquote\n          syntax-unquote\n          syntax-unquote-splicing)\n\n  ;; misc ",
"transformers\n\n  (export call-with-current-environment\n          make-syntactic-c",
"losure\n          close-syntax\n          strip-syntax\n          sc-macro-transfor",
"mer\n          rsc-macro-transformer\n          er-macro-transformer\n          ir-",
"macro-transformer)\n\n\n  (define-macro call-with-current-environment\n    (lambda (",
"form env)\n      `(,(cadr form) ',env)))\n\n\n  ;; syntactic closure\n\n\n  (define (ma",
"ke-syntactic-closure env free form)\n    (letrec\n        ((wrap (let ((ephemeron ",
"(make-ephemeron)))\n                 (lambda (var)\n                   (let ((id (",
"ephemeron var)))\n                     (if id\n                         (cdr id)\n ",
"                        (let ((id (make-identifier var env)))\n                  ",
"         (ephemeron var id)\n                           id))))))\n         (walk (",
"lambda (f form)\n                 (cond\n                  ((identifier? form)\n   ",
"                (f form))\n                  ((pair? form)\n                   (co",
"ns (walk f (car form)) (walk f (cdr form))))\n                  ((vector? form)\n ",
"                  (list->vector (walk f (vector->list form))))\n                 ",
" (else\n                   form)))))\n      (letrec\n          ((f (lambda (var)\n  ",
"              (let loop ((free free))\n                  (if (null? free)\n       ",
"               (wrap var)\n                      (if (identifier=? var (car free)",
")\n                          var\n                          (loop (cdr free)))))))",
")\n        (walk f form))))\n\n  (define (close-syntax form env)\n    (make-syntacti",
"c-closure env '() form))\n\n  (define (strip-syntax form)\n    (letrec\n        ((un",
"wrap (lambda (var)\n                   (identifier-base var)))\n         (walk (la",
"mbda (f form)\n                 (cond\n                  ((identifier? form)\n     ",
"              (f form))\n                  ((pair? form)\n                   (cons",
" (walk f (car form)) (walk f (cdr form))))\n                  ((vector? form)\n   ",
"                (list->vector (walk f (vector->list form))))\n                  (",
"else\n                   form)))))\n      (walk unwrap form)))\n\n\n  ;; transformers",
"\n\n\n  (define (sc-transformer f)\n    (lambda (form use-env mac-env)\n      (make-s",
"yntactic-closure mac-env '() (f form use-env))))\n\n  (define (rsc-transformer f)\n",
"    (lambda (form use-env mac-env)\n      (make-syntactic-closure use-env '() (f ",
"form mac-env))))\n\n  (define (er-transformer f)\n    (lambda (form use-env mac-env",
")\n      (letrec\n          ((rename (let ((ephemeron (make-ephemeron)))\n         ",
"            (lambda (var)\n                       (let ((id (ephemeron var)))\n   ",
"                      (if id\n                             (cdr id)\n             ",
"                (let ((id (make-identifier var mac-env)))\n                      ",
"         (ephemeron var id)\n                               id))))))\n           (",
"compare (lambda (x y)\n                      (identifier=?\n                      ",
" (make-identifier x use-env)\n                       (make-identifier y use-env))",
")))\n        (f form rename compare))))\n\n  (define (ir-transformer f)\n    (lambda",
" (form use-env mac-env)\n      (let ((ephemeron1 (make-ephemeron))\n            (e",
"phemeron2 (make-ephemeron)))\n        (letrec\n            ((inject (lambda (var1)",
"\n                       (let ((var2 (ephemeron1 var1)))\n                        ",
" (if var2\n                             (cdr var2)\n                             (",
"let ((var2 (make-identifier var1 use-env)))\n                               (ephe",
"meron1 var1 var2)\n                               (ephemeron2 var2 var1)\n        ",
"                       var2)))))\n             (rename (let ((ephemeron (make-eph",
"emeron)))\n                       (lambda (var)\n                         (let ((i",
"d (ephemeron var)))\n                           (if id\n                          ",
"     (cdr id)\n                               (let ((id (make-identifier var mac-",
"env)))\n                                 (ephemeron var id)\n                     ",
"            id))))))\n             (flip (lambda (var2) ; unwrap if injected, wra",
"p if not injected\n                     (let ((var1 (ephemeron2 var2)))\n         ",
"              (if var1\n                           (cdr var1)\n                   ",
"        (rename var2)))))\n             (walk (lambda (f form)\n                  ",
"   (cond\n                      ((identifier? form)\n                       (f for",
"m))\n                      ((pair? form)\n                       (cons (walk f (ca",
"r form)) (walk f (cdr form))))\n                      ((vector? form)\n           ",
"            (list->vector (walk f (vector->list form))))\n                      (",
"else\n                       form))))\n             (compare (lambda (x y)\n       ",
"                 (identifier=?\n                         (make-identifier x mac-e",
"nv)\n                         (make-identifier y mac-env)))))\n          (walk fli",
"p (f (walk inject form) inject compare))))))\n\n  (define-macro sc-macro-transform",
"er\n    (lambda (f mac-env)\n      #`(lambda (form use-env)\n          ((sc-transfo",
"rmer #,(cadr f)) form use-env #,mac-env))))\n\n  (define-macro rsc-macro-transform",
"er\n    (lambda (f mac-env)\n      #`(lambda (form use-env)\n          ((rsc-transf",
"ormer #,(cadr f)) form use-env #,mac-env))))\n\n  (define-macro er-macro-transform",
"er\n    (lambda (f mac-env)\n      #`(lambda (form use-env)\n          ((er-transfo",
"rmer #,(cadr f)) form use-env #,mac-env))))\n\n  (define-macro ir-macro-transforme",
"r\n    (lambda (f mac-env)\n      #`(lambda (form use-env)\n          ((ir-transfor",
"mer #,(cadr f)) form use-env #,mac-env)))))\n",
"",
};

static const char piclib_src_contrib_20_r7rs_scheme_base[][80] = {
"(define-library (scheme base)\n  (import (picrin base)\n          (only (picrin ma",
"th)\n                abs\n                expt\n                floor/\n            ",
"    truncate/\n                floor\n                ceiling\n                trun",
"cate\n                round\n                sqrt\n                nan?\n           ",
"     infinite?)\n          (picrin macro)\n          (scheme file))\n\n  ;; 4.1.2. L",
"iteral expressions\n\n  (export quote)\n\n  ;; 4.1.4. Procedures\n\n  (export lambda)\n",
"\n  ;; 4.1.5. Conditionals\n\n  (export if)\n\n  ;; 4.1.6. Assignments\n\n  (export set",
"!)\n\n  ;; 4.1.7. Inclusion\n\n  (define-macro include\n    (letrec ((read-file\n     ",
"         (lambda (filename)\n                (call-with-port (open-input-file fil",
"ename)\n                  (lambda (port)\n                    (let loop ((expr (re",
"ad port)) (exprs '()))\n                      (if (eof-object? expr)\n            ",
"              (reverse exprs)\n                          (loop (read port) (cons ",
"expr exprs)))))))))\n      (er-macro-transformer\n       (lambda (form rename comp",
"are)\n         (let ((filenames (cdr form)))\n           (let ((exprs (apply appen",
"d (map read-file filenames))))\n             `(,(rename 'begin) ,@exprs)))))))\n\n ",
" (export include)\n\n  ;; 4.2.1. Conditionals\n\n  (export cond\n          case\n     ",
"     else\n          =>\n          and\n          or\n          when\n          unles",
"s)\n\n  ;; 4.2.2. Binding constructs\n\n  (export let\n          let*\n          letre",
"c\n          letrec*\n          let-values\n          let*-values)\n\n  ;; 4.2.3. Seq",
"uencing\n\n  (export begin)\n\n  ;; 4.2.4. Iteration\n\n  (export do)\n\n  ;; 4.2.6. Dyn",
"amic bindings\n\n  (export make-parameter\n          parameterize)\n\n  ;; 4.2.7. Exc",
"eption handling\n\n  (define-syntax (guard-aux reraise . clauses)\n    (letrec\n    ",
"    ((else?\n          (lambda (clause)\n            (and (list? clause) (equal? #",
"'else (car clause)))))\n         (=>?\n          (lambda (clause)\n            (and",
" (list? clause) (= (length clause) 3) (equal? #'=> (list-ref clause 1))))))\n    ",
"  (if (null? clauses)\n          reraise\n          (let ((clause (car clauses))\n ",
"               (rest (cdr clauses)))\n            (cond\n             ((else? clau",
"se)\n              #`(begin #,@(cdr clause)))\n             ((=>? clause)\n        ",
"      #`(let ((tmp #,(list-ref clause 0)))\n                  (if tmp\n           ",
"           (#,(list-ref clause 2) tmp)\n                      (guard-aux #,rerais",
"e #,@rest))))\n             ((= (length clause) 1)\n              #`(or #,(car cla",
"use) (guard-aux #,reraise #,@rest)))\n             (else\n              #`(if #,(c",
"ar clause)\n                    (begin #,@(cdr clause))\n                    (guar",
"d-aux #,reraise #,@rest))))))))\n\n  (define-syntax (guard formal . body)\n    (let",
" ((var (car formal))\n          (clauses (cdr formal)))\n      #`((call/cc\n       ",
"   (lambda (guard-k)\n            (with-exception-handler\n             (lambda (c",
"ondition)\n               ((call/cc\n                 (lambda (handler-k)\n        ",
"           (guard-k\n                    (lambda ()\n                      (let ((",
"#,var condition))\n                        (guard-aux\n                         (h",
"andler-k\n                          (lambda ()\n                            (raise",
"-continuable condition)))\n                         #,@clauses))))))))\n          ",
"   (lambda ()\n               (call-with-values\n                   (lambda () #,@",
"body)\n                 (lambda args\n                   (guard-k\n                ",
"    (lambda ()\n                      (apply values args))))))))))))\n\n  (export g",
"uard)\n\n  ;; 4.2.8. Quasiquotation\n\n  (export quasiquote\n          unquote\n      ",
"    unquote-splicing)\n\n  ;; 4.3.1. Binding constructs for syntactic keywords\n\n  ",
"(export let-syntax\n          letrec-syntax)\n\n  ;; 4.3.2 Pattern language\n\n  (def",
"ine (succ n)\n    (+ n 1))\n\n  (define (pred n)\n    (if (= n 0)\n        0\n        ",
"(- n 1)))\n\n  (define (every? args)\n    (if (null? args)\n        #t\n        (if (",
"car args)\n            (every? (cdr args))\n            #f)))\n\n  (define (filter f",
" list)\n    (if (null? list)\n        '()\n        (if (f (car list))\n            (",
"cons (car list)\n                  (filter f (cdr list)))\n            (filter f (",
"cdr list)))))\n\n  (define (take-tail n list)\n    (let drop ((n (- (length list) n",
")) (list list))\n      (if (= n 0)\n          list\n          (drop (- n 1) (cdr li",
"st)))))\n\n  (define (drop-tail n list)\n    (let take ((n (- (length list) n)) (li",
"st list))\n      (if (= n 0)\n          '()\n          (cons (car list) (take (- n ",
"1) (cdr list))))))\n\n  (define (map-keys f assoc)\n    (map (lambda (s) `(,(f (car",
" s)) . ,(cdr s))) assoc))\n\n  (define (map-values f assoc)\n    (map (lambda (s) `",
"(,(car s) . ,(f (cdr s)))) assoc))\n\n  ;; TODO\n  ;; - placeholder\n  ;; - vector\n ",
" ;; - (... template) pattern\n\n  ;; p ::= constant\n  ;;     | var\n  ;;     | (p .",
".. . p)      (in input pattern, tail p should be a proper list)\n  ;;     | (p . ",
"p)\n\n  (define (compile ellipsis literals rules)\n\n    (define (constant? obj)\n   ",
"   (and (not (pair? obj))\n           (not (identifier? obj))))\n\n    (define (lit",
"eral? obj)\n      (and (identifier? obj)\n           (memq obj literals)))\n\n    (d",
"efine (many? pat)\n      (and (pair? pat)\n           (pair? (cdr pat))\n          ",
" (identifier? (cadr pat))\n           (identifier=? (cadr pat) ellipsis)))\n\n    (",
"define (pattern-validator pat)      ; pattern -> validator\n      (letrec\n       ",
"   ((pattern-validator\n            (lambda (pat form)\n              (cond\n      ",
"         ((constant? pat)\n                #`(equal? '#,pat #,form))\n            ",
"   ((literal? pat)\n                #`(and (identifier? #,form) (identifier=? #'#",
",pat #,form)))\n               ((identifier? pat)\n                #t)\n           ",
"    ((many? pat)\n                (let ((head #`(drop-tail #,(length (cddr pat)) ",
"#,form))\n                      (tail #`(take-tail #,(length (cddr pat)) #,form))",
")\n                  #`(and (list? #,form)\n                         (>= (length #",
",form) #,(length (cddr pat)))\n                         (every? (map (lambda (#,'",
"it) #,(pattern-validator (car pat) 'it)) #,head))\n                         #,(pa",
"ttern-validator (cddr pat) tail))))\n               ((pair? pat)\n                ",
"#`(and (pair? #,form)\n                       #,(pattern-validator (car pat) #`(c",
"ar #,form))\n                       #,(pattern-validator (cdr pat) #`(cdr #,form)",
")))\n               (else\n                #f)))))\n        (pattern-validator pat ",
"'it)))\n\n    (define (pattern-variables pat)       ; pattern -> (freevar)\n      (",
"cond\n       ((constant? pat)\n        '())\n       ((literal? pat)\n        '())\n  ",
"     ((identifier? pat)\n        `(,pat))\n       ((many? pat)\n        (append (pa",
"ttern-variables (car pat))\n                (pattern-variables (cddr pat))))\n    ",
"   ((pair? pat)\n        (append (pattern-variables (car pat))\n                (p",
"attern-variables (cdr pat))))))\n\n    (define (pattern-levels pat)          ; pat",
"tern -> ((var * int))\n      (cond\n       ((constant? pat)\n        '())\n       ((",
"literal? pat)\n        '())\n       ((identifier? pat)\n        `((,pat . 0)))\n    ",
"   ((many? pat)\n        (append (map-values succ (pattern-levels (car pat)))\n   ",
"             (pattern-levels (cddr pat))))\n       ((pair? pat)\n        (append (",
"pattern-levels (car pat))\n                (pattern-levels (cdr pat))))))\n\n    (d",
"efine (pattern-selectors pat)       ; pattern -> ((var * selector))\n      (letre",
"c\n          ((pattern-selectors\n            (lambda (pat form)\n              (co",
"nd\n               ((constant? pat)\n                '())\n               ((literal",
"? pat)\n                '())\n               ((identifier? pat)\n                `(",
"(,pat . ,form)))\n               ((many? pat)\n                (let ((head #`(drop",
"-tail #,(length (cddr pat)) #,form))\n                      (tail #`(take-tail #,",
"(length (cddr pat)) #,form)))\n                  (let ((envs (pattern-selectors (",
"car pat) 'it)))\n                    (append\n                     (map-values (la",
"mbda (s) #`(map (lambda (#,'it) #,s) #,head)) envs)\n                     (patter",
"n-selectors (cddr pat) tail)))))\n               ((pair? pat)\n                (ap",
"pend (pattern-selectors (car pat) #`(car #,form))\n                        (patte",
"rn-selectors (cdr pat) #`(cdr #,form))))))))\n        (pattern-selectors pat 'it)",
"))\n\n    (define (template-representation pat levels selectors)\n      (cond\n     ",
"  ((constant? pat)\n        pat)\n       ((identifier? pat)\n        (let ((it (ass",
"q pat levels)))\n          (if it\n              (if (= 0 (cdr it))\n              ",
"    (cdr (assq pat selectors))\n                  (error \"unmatched pattern varia",
"ble level\" pat))\n              #`(#,'rename '#,pat))))\n       ((many? pat)\n     ",
"   (letrec*\n            ((inner-pat\n              (car pat))\n             (inner",
"-levels\n              (map (lambda (s) `(,(car s) . ,(pred (cdr s)))) levels))\n ",
"            (inner-freevars\n              (filter (lambda (v) (assq v levels)) (",
"pattern-variables inner-pat)))\n             (inner-vars\n              ;; select ",
"only vars declared with ellipsis\n              (filter (lambda (v) (> (cdr (assq",
" v levels)) 0)) inner-freevars))\n             (inner-tmps\n              (map (la",
"mbda (v) #'it) inner-vars))\n             (inner-selectors\n              ;; first",
" env '(map cons ...)' shadows second env 'selectors'\n              (append (map ",
"cons inner-vars inner-tmps) selectors))\n             (inner-rep\n              (t",
"emplate-representation inner-pat inner-levels inner-selectors))\n             (so",
"rted-selectors\n              (map (lambda (v) (assq v selectors)) inner-vars))\n ",
"            (list-of-selectors\n              ;; ((a . xs) (b . ys) (c . zs)) -> ",
"(xs ys zs)\n              (map cdr sorted-selectors)))\n          (let ((rep1 #`(m",
"ap (lambda #,inner-tmps #,inner-rep) #,@list-of-selectors))\n                (rep",
"2 (template-representation (cddr pat) levels selectors)))\n            #`(append ",
"#,rep1 #,rep2))))\n       ((pair? pat)\n        #`(cons #,(template-representation",
" (car pat) levels selectors)\n                #,(template-representation (cdr pat",
") levels selectors)))))\n\n    (define (compile-rule pattern template)\n      (let ",
"((levels\n             (pattern-levels pattern))\n            (selectors\n         ",
"    (pattern-selectors pattern)))\n        (template-representation template leve",
"ls selectors)))\n\n    (define (compile-rules rules)\n      (if (null? rules)\n     ",
"     #`(error \"unmatch\")\n          (let ((pattern (car (car rules)))\n           ",
"     (template (cadr (car rules))))\n            #`(if #,(pattern-validator patte",
"rn)\n                  #,(compile-rule pattern template)\n                  #,(com",
"pile-rules (cdr rules))))))\n\n    (define (compile rules)\n      #`(call-with-curr",
"ent-environment\n         (lambda (env)\n           (letrec\n               ((#,'re",
"name (let ((wm (make-ephemeron)))\n                             (lambda (x)\n     ",
"                          (let ((y (wm x)))\n                                 (if",
" y\n                                     (cdr y)\n                                ",
"     (let ((id (make-identifier x env)))\n                                       ",
"(wm x id)\n                                       id)))))))\n             (lambda ",
"#,'it\n               #,(compile-rules rules))))))\n\n    (let ((rules (map-keys cd",
"r rules))) ; TODO: check pattern head is a variable\n      (compile rules)))\n\n  (",
"define-syntax (syntax-rules . args)\n    (if (list? (car args))\n        #`(syntax",
"-rules ... #,@args)\n        (let ((ellipsis (car args))\n              (literals ",
"(car (cdr args)))\n              (rules    (cdr (cdr args))))\n          (compile ",
"ellipsis literals rules))))\n\n  (define-syntax (define-auxiliary-syntax var)\n    ",
"#`(define-macro #,var\n        (lambda _\n          (error \"invalid use of auxilia",
"ry syntax\" '#,var))))\n\n  (define-auxiliary-syntax _)\n  (define-auxiliary-syntax ",
"...)\n\n  (export syntax-rules\n          _\n          ...)\n\n  ;; 4.3.3. Signaling e",
"rrors in macro transformers\n\n  (export syntax-error)\n\n  ;; 5.3. Variable definit",
"ions\n\n  (export define)\n\n  ;; 5.3.3. Multiple-value definitions\n\n  (export defin",
"e-values)\n\n  ;; 5.4. Syntax definitions\n\n  (export define-syntax)\n\n  ;; 5.5 Reco",
"rd-type definitions\n\n  (define (make-record-type name)\n    (vector name))       ",
"               ; TODO\n\n  (define-syntax (define-record-constructor type field-al",
"ist name . fields)\n    (let ((record #'record))\n      #`(define (#,name . #,fiel",
"ds)\n          (let ((#,record (make-record #,type (make-vector #,(length field-a",
"list)))))\n            #,@(map\n                (lambda (field)\n                  ",
"#`(vector-set! (record-datum #,record) #,(cdr (assq field field-alist)) #,field)",
") \n                fields)\n            #,record))))\n\n  (define-syntax (define-re",
"cord-predicate type name)\n    #`(define (#,name obj)\n        (and (record? obj)\n",
"             (eq? (record-type obj) #,type))))\n\n  (define-syntax (define-record-",
"accessor pred field-alist field accessor)\n    #`(define (#,accessor record)\n    ",
"    (if (#,pred record)\n            (vector-ref (record-datum record) #,(cdr (as",
"sq field field-alist)))\n            (error (string-append (symbol->string  '#,ac",
"cessor) \": wrong record type\") record))))\n\n  (define-syntax (define-record-modif",
"ier pred field-alist field modifier)\n    #`(define (#,modifier record val)\n     ",
"   (if (#,pred record)\n            (vector-set! (record-datum record) #,(cdr (as",
"sq field field-alist)) val)\n            (error (string-append (symbol->string '#",
",modifier) \": wrong record type\")  record))))\n\n  (define-syntax (define-record-f",
"ield pred field-alist field accessor . modifier-opt)\n    (if (null? modifier-opt",
")\n        #`(define-record-accessor #,pred #,field-alist #,field #,accessor)\n   ",
"     #`(begin\n            (define-record-accessor #,pred #,field-alist #,field #",
",accessor)\n            (define-record-modifier #,pred #,field-alist #,field #,(c",
"ar modifier-opt)))))\n\n  (define-syntax (define-record-type name ctor pred . fiel",
"ds)\n    (let ((field-alist (let lp ((fds fields) (idx 0) (alst '()))\n           ",
"                 (if (null? fds)\n                              alst\n            ",
"                  (lp (cdr fds)\n                                  (+ idx 1)\n    ",
"                              (cons\n                                    (cons (i",
"f (pair? (car fds)) (car (car fds)) (car fds)) idx)\n                            ",
"        alst))))))\n      #`(begin\n          (define #,name (make-record-type '#,",
"name))\n          (define-record-constructor #,name #,field-alist #,@ctor)\n      ",
"    (define-record-predicate #,name #,pred)\n          #,@(map (lambda (field) #`",
"(define-record-field #,pred #,field-alist #,@field)) fields))))\n\n  (export defin",
"e-record-type)\n\n  ;; 6.1. Equivalence predicates\n\n  (export eq?\n          eqv?\n ",
"         equal?)\n\n  ;; 6.2. Numbers\n\n  (define complex? number?)\n  (define real?",
" number?)\n  (define rational? number?)\n  (define (integer? o)\n    (or (exact? o)",
"\n        (and (inexact? o)\n             (not (nan? o))\n             (not (infini",
"te? o))\n             (= o (floor o)))))\n\n  (define (exact-integer? x)\n    (and (",
"exact? x)\n         (integer? x)))\n\n  (define (zero? x)\n    (= x 0))\n\n  (define (",
"positive? x)\n    (> x 0))\n\n  (define (negative? x)\n    (< x 0))\n\n  (define (even",
"? x)\n    (= x (* (exact (floor (/ x 2))) 2)))\n\n  (define (odd? x)\n    (not (even",
"? x)))\n\n  (define (min . args)\n    (define (min a b)\n      (if (< a b) a b))\n   ",
" (let loop ((args args) (acc +inf.0) (exactp #t))\n      (if (null? args)\n       ",
"   (if exactp acc (inexact acc))\n          (loop (cdr args) (min (car args) acc)",
" (and (exact? (car args)) exactp)))))\n\n  (define (max . args)\n    (define (max a",
" b)\n      (if (> a b) a b))\n    (let loop ((args args) (acc -inf.0) (exactp #t))",
"\n      (if (null? args)\n          (if exactp acc (inexact acc))\n          (loop ",
"(cdr args) (max (car args) acc) (and (exact? (car args)) exactp)))))\n\n  (define ",
"(floor-quotient i j)\n    (call-with-values (lambda () (floor/ i j))\n      (lambd",
"a (q r)\n        q)))\n\n  (define (floor-remainder i j)\n    (call-with-values (lam",
"bda () (floor/ i j))\n      (lambda (q r)\n        r)))\n\n  (define (truncate-quoti",
"ent i j)\n    (call-with-values (lambda () (truncate/ i j))\n      (lambda (q r)\n ",
"       q)))\n\n  (define (truncate-remainder i j)\n    (call-with-values (lambda ()",
" (truncate/ i j))\n      (lambda (q r)\n        r)))\n\n  (define (gcd . args)\n    (",
"define (gcd i j)\n      (cond\n       ((> i j) (gcd j i))\n       ((< i 0) (gcd (- ",
"i) j))\n       ((> i 0) (gcd (truncate-remainder j i) i))\n       (else j)))\n    (",
"let loop ((args args) (acc 0))\n      (if (null? args)\n          acc\n          (l",
"oop (cdr args)\n                (gcd acc (car args))))))\n\n  (define (lcm . args)\n",
"    (define (lcm i j)\n      (/ (abs (* i j)) (gcd i j)))\n    (let loop ((args ar",
"gs) (acc 1))\n      (if (null? args)\n          acc\n          (loop (cdr args)\n   ",
"             (lcm acc (car args))))))\n\n  (define (square x)\n    (* x x))\n\n  (def",
"ine (exact-integer-sqrt k)\n    (let ((s (exact (floor (sqrt k)))))\n      (values",
" s (- k (square s)))))\n\n  (export number?\n          complex?\n          real?\n   ",
"       rational?\n          integer?\n          exact?\n          inexact?\n        ",
"  exact-integer?\n          exact\n          inexact\n          =\n          <\n     ",
"     >\n          <=\n          >=\n          zero?\n          positive?\n          n",
"egative?\n          odd?\n          even?\n          min\n          max\n          +\n",
"          -\n          *\n          /\n          abs\n          floor-quotient\n     ",
"     floor-remainder\n          floor/\n          truncate-quotient\n          trun",
"cate-remainder\n          truncate/\n          (rename truncate-quotient quotient)",
"\n          (rename truncate-remainder remainder)\n          (rename floor-remaind",
"er modulo)\n          gcd\n          lcm\n          floor\n          ceiling\n       ",
"   truncate\n          round\n          exact-integer-sqrt\n          square\n      ",
"    expt\n          number->string\n          string->number)\n\n  ;; 6.3. Booleans\n",
"\n  (export boolean?\n          boolean=?\n          not)\n\n  ;; 6.4 Pairs and lists",
"\n\n  (export pair?\n          cons\n          car\n          cdr\n          set-car!\n",
"          set-cdr!\n          null?\n          caar\n          cadr\n          cdar\n",
"          cddr\n          list?\n          make-list\n          list\n          leng",
"th\n          append\n          reverse\n          list-tail\n          list-ref\n   ",
"       list-set!\n          list-copy\n          memq\n          memv\n          mem",
"ber\n          assq\n          assv\n          assoc)\n\n  ;; 6.5. Symbols\n\n  (export",
" symbol?\n          symbol=?\n          symbol->string\n          string->symbol)\n\n",
"  ;; 6.6. Characters\n\n  (export char?\n          char->integer\n          integer-",
">char\n          char=?\n          char<?\n          char>?\n          char<=?\n     ",
"     char>=?)\n\n  ;; 6.7. Strings\n\n  (export string?\n          string\n          m",
"ake-string\n          string-length\n          string-ref\n          string-set!\n  ",
"        string-copy\n          string-copy!\n          string-append\n          (re",
"name string-copy substring)\n          string-fill!\n          string->list\n      ",
"    list->string\n          string=?\n          string<?\n          string>?\n      ",
"    string<=?\n          string>=?)\n\n  ;; 6.8. Vectors\n\n  (export vector?\n       ",
"   vector\n          make-vector\n          vector-length\n          vector-ref\n   ",
"       vector-set!\n          vector-copy!\n          vector-copy\n          vector",
"-append\n          vector-fill!\n          list->vector\n          vector->list\n   ",
"       string->vector\n          vector->string)\n\n  ;; 6.9. Bytevectors\n\n  (defin",
"e (utf8->string v . opts)\n    (let ((start (if (pair? opts) (car opts) 0))\n     ",
"     (end (if (>= (length opts) 2)\n                   (cadr opts)\n              ",
"     (bytevector-length v))))\n      (list->string (map integer->char (bytevector",
"->list v start end)))))\n\n  (define (string->utf8 s . opts)\n    (let ((start (if ",
"(pair? opts) (car opts) 0))\n          (end (if (>= (length opts) 2)\n            ",
"       (cadr opts)\n                   (string-length s))))\n      (list->bytevect",
"or (map char->integer (string->list s start end)))))\n\n  (export bytevector?\n    ",
"      bytevector\n          make-bytevector\n          bytevector-length\n         ",
" bytevector-u8-ref\n          bytevector-u8-set!\n          bytevector-copy\n      ",
"    bytevector-copy!\n          bytevector-append\n          bytevector->list\n    ",
"      list->bytevector\n          utf8->string\n          string->utf8)\n\n  ;; 6.10",
". Control features\n\n  (export procedure?\n          apply\n          map\n         ",
" for-each\n          string-map\n          string-for-each\n          vector-map\n  ",
"        vector-for-each\n          call-with-current-continuation\n          call/",
"cc\n          dynamic-wind\n          values\n          call-with-values)\n\n  ;; 6.1",
"1. Exceptions\n\n  (define (read-error? obj)\n    (and (error-object? obj)\n        ",
" (eq? (error-object-type obj) 'read)))\n\n  (define (file-error? obj)\n    (and (er",
"ror-object? obj)\n         (eq? (error-object-type obj) 'file)))\n\n  (export with-",
"exception-handler\n          raise\n          raise-continuable\n          error\n  ",
"        error-object?\n          error-object-message\n          error-object-irri",
"tants\n          read-error?\n          file-error?)\n\n  ;; 6.13. Input and output\n",
"\n  (define (input-port-open? port)\n    (and (input-port? port) (port-open? port)",
"))\n\n  (define (output-port-open? port)\n    (and (output-port? port) (port-open? ",
"port)))\n\n  (define (call-with-port port handler)\n    (let ((res (handler port)))",
"\n      (close-port port)\n      res))\n\n  (define (open-input-string str)\n    (ope",
"n-input-bytevector (list->bytevector (map char->integer (string->list str)))))\n\n",
"  (define (open-output-string)\n    (open-output-bytevector))\n\n  (define (get-out",
"put-string port)\n    (list->string (map integer->char (bytevector->list (get-out",
"put-bytevector port)))))\n\n  (define (read-char . opt)\n    (let ((b (apply read-u",
"8 opt)))\n      (if (eof-object? b)\n          b\n          (integer->char b))))\n\n ",
" (define (peek-char . opt)\n    (let ((b (apply peek-u8 opt)))\n      (if (eof-obj",
"ect? b)\n          b\n          (integer->char b))))\n\n  (define (u8-ready? . opt)\n",
"    #t)\n\n  (define (read-bytevector k . opt)\n    (let ((port (if (null? opt) (cu",
"rrent-input-port) (car opt))))\n      (let ((buf (make-bytevector k)))\n        (l",
"et ((n (read-bytevector! buf port 0 k)))\n          (if (eof-object? n)\n         ",
"     (eof-object)\n              (bytevector-copy buf 0 n))))))\n\n  (define (char-",
"ready? . opt)\n    #t)\n\n  (define (newline . opt)\n    (apply write-u8 (char->inte",
"ger #\\newline) opt))\n\n  (define (write-char c . opt)\n    (apply write-u8 (char->",
"integer c) opt))\n\n  (define (write-string s . opt)\n    (apply write-bytevector (",
"list->bytevector (map char->integer (string->list s))) opt))\n\n  (define (read-li",
"ne . opt)\n    (if (eof-object? (apply peek-char opt))\n        (eof-object)\n     ",
"   (let loop ((str \"\") (c (apply read-char opt)))\n          (if (or (eof-object?",
" c)\n                  (char=? c #\\newline))\n              str\n              (loo",
"p (string-append str (string c)) (apply read-char opt))))))\n\n  (define (read-str",
"ing k . opt)\n    (if (eof-object? (apply peek-char opt))\n        (eof-object)\n  ",
"      (let loop ((k k) (str \"\") (c (apply read-char opt)))\n          (if (or (eo",
"f-object? c)\n                  (zero? k))\n              str\n              (loop ",
"(- k 1) (string-append str (string c)) (apply read-char opt))))))\n\n  (export cur",
"rent-input-port\n          current-output-port\n          current-error-port\n\n    ",
"      call-with-port\n\n          port?\n          input-port?\n          output-por",
"t?\n          (rename port? textual-port?)\n          (rename port? binary-port?)\n",
"\n          input-port-open?\n          output-port-open?\n          close-port\n   ",
"       (rename close-port close-input-port)\n          (rename close-port close-o",
"utput-port)\n\n          open-input-string\n          open-output-string\n          ",
"get-output-string\n          open-input-bytevector\n          open-output-bytevect",
"or\n          get-output-bytevector\n\n          eof-object?\n          eof-object\n\n",
"          read-char\n          peek-char\n          char-ready?\n          read-lin",
"e\n          read-string\n\n          read-u8\n          peek-u8\n          u8-ready?",
"\n          read-bytevector\n          read-bytevector!\n\n          newline\n       ",
"   write-char\n          write-string\n          write-u8\n          write-bytevect",
"or\n          flush-output-port)\n\n  (export features))\n",
"",
};

static const char piclib_src_contrib_20_r7rs_scheme_cxr[][80] = {
";;; Appendix A. Standard Libraries CxR\n\n(define-library (scheme cxr)\n  (import (",
"scheme base))\n\n  (define (caaar p) (car (caar p)))\n  (define (caadr p) (car (cad",
"r p)))\n  (define (cadar p) (car (cdar p)))\n  (define (caddr p) (car (cddr p)))\n ",
" (define (cdaar p) (cdr (caar p)))\n  (define (cdadr p) (cdr (cadr p)))\n  (define",
" (cddar p) (cdr (cdar p)))\n  (define (cdddr p) (cdr (cddr p)))\n  (define (caaaar",
" p) (caar (caar p)))\n  (define (caaadr p) (caar (cadr p)))\n  (define (caadar p) ",
"(caar (cdar p)))\n  (define (caaddr p) (caar (cddr p)))\n  (define (cadaar p) (cad",
"r (caar p)))\n  (define (cadadr p) (cadr (cadr p)))\n  (define (caddar p) (cadr (c",
"dar p)))\n  (define (cadddr p) (cadr (cddr p)))\n  (define (cdaaar p) (cdar (caar ",
"p)))\n  (define (cdaadr p) (cdar (cadr p)))\n  (define (cdadar p) (cdar (cdar p)))",
"\n  (define (cdaddr p) (cdar (cddr p)))\n  (define (cddaar p) (cddr (caar p)))\n  (",
"define (cddadr p) (cddr (cadr p)))\n  (define (cdddar p) (cddr (cdar p)))\n  (defi",
"ne (cddddr p) (cddr (cddr p)))\n\n  (export caaar caadr cadar caddr\n          cdaa",
"r cdadr cddar cdddr\n          caaaar caaadr caadar caaddr\n          cadaar cadad",
"r caddar cadddr\n          cdaaar cdaadr cdadar cdaddr\n          cddaar cddadr cd",
"ddar cddddr))\n",
"",
};

static const char piclib_src_contrib_20_r7rs_scheme_read[][80] = {
"(define-library (scheme read)\n  (import (picrin base))\n\n  (export read))\n",
"",
};

static const char piclib_src_contrib_20_r7rs_scheme_write[][80] = {
"(define-library (scheme write)\n  (import (picrin base))\n\n  (export write\n       ",
"   write-simple\n          write-shared\n          display))\n",
"",
};

static const char piclib_src_contrib_20_r7rs_scheme_file[][80] = {
"(define-library (scheme file)\n  (import (picrin base)\n          (scheme base))\n\n",
"  (define (call-with-input-file filename callback)\n    (call-with-port (open-inp",
"ut-file filename) callback))\n\n  (define (call-with-output-file filename callback",
")\n    (call-with-port (open-output-file filename) callback))\n\n  (define (with-in",
"put-from-file filename thunk)\n    (call-with-input-file filename\n      (lambda (",
"port)\n        (parameterize ((current-input-port port))\n          (thunk)))))\n\n ",
" (define (with-output-to-file filename thunk)\n    (call-with-output-file filenam",
"e\n      (lambda (port)\n        (parameterize ((current-output-port port))\n      ",
"    (thunk)))))\n\n  (export open-input-file\n          open-binary-input-file\n    ",
"      open-output-file\n          open-binary-output-file\n          delete-file\n ",
"         file-exists?\n          call-with-input-file\n          call-with-output-",
"file\n          with-input-from-file\n          with-output-to-file))\n",
"",
};

static const char piclib_src_contrib_20_r7rs_scheme_case_lambda[][80] = {
"(define-library (scheme case-lambda)\n  (import (scheme base))\n\n  (define (length",
"+ list)\n    (if (pair? list)\n        (+ 1 (length+ (cdr list)))\n        0))\n\n  (",
"define-syntax case-lambda\n    (syntax-rules ()\n      ((case-lambda (params body0",
" ...) ...)\n       (lambda args\n         (let ((len (length args)))\n           (l",
"etrec-syntax\n               ((cl (syntax-rules ()\n                      ((cl)\n  ",
"                     (error \"no matching clause\"))\n                      ((cl (f",
"ormal . body) . rest)\n                       (if (if (list? 'formal)\n           ",
"                    (= len (length 'formal))\n                               (>= ",
"len (length+ 'formal)))\n                           (apply (lambda formal . body)",
" args)\n                           (cl . rest))))))\n             (cl (params body",
"0 ...) ...)))))))\n\n  (export case-lambda))\n",
"",
};

static const char piclib_src_contrib_20_r7rs_scheme_lazy[][80] = {
";;; Appendix A. Standard Libraries Lazy\n\n(define-library (scheme lazy)\n  (import",
" (scheme base))\n\n  ;; type 'a <promise> = cached of 'a | chained of 'a promise |",
" pending of () -> 'a promise\n\n  (define-record-type <promise>\n      (promise sta",
"te value)\n      promise?\n    (state promise-state set-promise-state!)\n    (value",
" promise-value set-promise-value!))\n\n  (define (make-promise obj)\n    (if (promi",
"se? obj)\n	obj\n	(promise 'cached obj)))\n\n  (define-syntax delay-force\n    (syntax",
"-rules ()\n      ((_ expr)\n       (promise (string->symbol \"pending\") (lambda () ",
"expr)))))\n\n  (define-syntax delay\n    (syntax-rules ()\n      ((_ expr)\n       (d",
"elay-force (make-promise expr)))))\n\n  (define (force p)\n    (let ((v (promise-va",
"lue p)))\n      (case (promise-state p)\n        ((cached)  v)\n        ((chained) ",
"(let ()\n                     (when (eq? 'cached (promise-state v))\n             ",
"          (set-promise-state! p 'cached)\n                       (set-promise-val",
"ue! p (promise-value v)))\n                     (force v)))\n        ((pending) (l",
"et ((q (v)))\n                     (when (eq? 'pending (promise-state p))\n       ",
"                (set-promise-state! p 'chained)\n                       (set-prom",
"ise-value! p q))\n                     (force p))))))\n\n  (export delay-force\n    ",
"      delay\n          force\n          make-promise\n          promise?))\n",
"",
};

static const char piclib_src_contrib_20_r7rs_scheme_eval[][80] = {
"(define-library (scheme eval)\n  (import (picrin base))\n\n  (define counter 0)\n\n  ",
"(define-syntax (inc! n)\n    #`(set! #,n (+ #,n 1)))\n\n  (define (environment . sp",
"ecs)\n    (let ((lib (string-append \"picrin.@@my-environment.\" (number->string co",
"unter))))\n      (inc! counter)\n      (make-library lib)\n      (eval `(import ,@s",
"pecs) lib)\n      lib))\n\n  (export environment eval))\n",
"",
};

static const char piclib_src_contrib_20_r7rs_scheme_inexact[][80] = {
"(define-library (scheme inexact)\n  (import (picrin base)\n          (picrin math)",
")\n\n  (export acos\n          asin\n          atan\n          cos\n          exp\n    ",
"      finite?\n          infinite?\n          log\n          nan?\n          sin\n   ",
"       sqrt\n          tan))\n",
"",
};

static const char piclib_src_contrib_20_r7rs_scheme_load[][80] = {
"(define-library (scheme load)\n  (import (picrin base))\n\n  (export load))\n",
"",
};

static const char piclib_src_contrib_20_r7rs_scheme_process_context[][80] = {
"(define-library (scheme process-context)\n  (import (picrin base))\n\n  (export com",
"mand-line\n          emergency-exit\n          exit\n          get-environment-vari",
"able\n          get-environment-variables))\n",
"",
};

static const char piclib_src_contrib_20_r7rs_scheme_time[][80] = {
"(define-library (scheme time)\n  (import (picrin base))\n\n  (export current-jiffy\n",
"          current-second\n          jiffies-per-second))\n",
"",
};

static const char piclib_src_contrib_20_r7rs_scheme_r5rs[][80] = {
"(define-library (scheme r5rs)\n  (import (scheme base)\n          (scheme inexact)",
"\n          (scheme write)\n          (scheme read)\n          (scheme file)\n      ",
"    (scheme cxr)\n          (scheme lazy)\n          (scheme eval)\n          (sche",
"me load)\n          (only (picrin base)\n                library-environment\n     ",
"           find-library))\n\n  (define-library (scheme null)\n    (import (scheme b",
"ase))\n    (export define\n            lambda\n            if\n            quote\n   ",
"         quasiquote\n            unquote\n            unquote-splicing\n           ",
" begin\n            set!\n            define-syntax))\n\n  (define (null-environment",
" n)\n    (if (not (= n 5))\n        (error \"unsupported environment version\" n)\n  ",
"      \"scheme.null\"))\n\n  (define (scheme-report-environment n)\n    (if (not (= n",
" 5))\n        (error \"unsupported environment version\" n)\n        \"scheme.r5rs\"))",
"\n\n  (export * + - / < <= = > >=\n          abs acos and\n          ;; angle\n      ",
"    append apply asin assoc assq assv atan\n          begin boolean?\n          ca",
"aaar caaadr caaar caadar caaddr caadr caar cadaar cadadr cadar caddar cadddr cad",
"dr cadr\n          call-with-current-continuation\n          call-with-input-file\n",
"          call-with-output-file\n          call-with-values\n          car case cd",
"aaar cdaadr cdaar cdadar cdaddr cdadr cdar cddaar cddadr cddar cdddar cddddr cdd",
"dr cddr cdr\n          ceiling\n          ;; char->integer char-alphabetic? char-c",
"i<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? cha",
"r-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? cha",
"r<? char=? char>=? char>? char?\n          close-input-port close-output-port com",
"plex? cond cons cos current-input-port current-output-port\n          define defi",
"ne-syntax delay\n          ;; denominator\n          display do dynamic-wind\n     ",
"     eof-object? eq? equal? eqv? eval even?\n          (rename inexact exact->ine",
"xact)\n          exact? exp expt\n          floor for-each force\n          gcd\n   ",
"       if\n          ;; imag-part\n          (rename exact inexact->exact)\n       ",
"   inexact? input-port? integer->char integer?\n          ;; interaction-environm",
"ent\n          lambda lcm length let\n          peek-char procedure?\n          quo",
"te\n          rational? read\n          ;; real-part\n          remainder round\n   ",
"       scheme-report-environment\n          set! set-cdr! sqrt string->list strin",
"g->symbol\n          ;; string-ci<=? string-ci=? string-ci>?\n          string-fil",
"l! string-ref string<=? string=? string>? substring symbol?\n          truncate\n ",
"         vector vector-fill! vector-ref vector? with-output-to-file write-char\n ",
"         output-port?\n          let-syntax\n          letrec-syntax\n          lis",
"t->string\n          list-ref\n          list?\n          log\n          ;; make-pol",
"ar\n          make-string\n          map\n          member\n          memv\n         ",
" modulo\n          newline\n          null-environment\n          number->string\n  ",
"        ;; numerator\n          open-input-file\n          or\n          pair?\n    ",
"      positive?\n          quasiquote\n          quotient\n          ;; rationalize",
"\n          read-char\n          real?\n          reverse\n          let*\n          ",
"letrec\n          list\n          list->vector\n          list-tail\n          load\n",
"          ;; magnitude\n          ;; make-rectangular\n          make-vector\n     ",
"     max\n          memq\n          min\n          negative?\n          not\n        ",
"  null?\n          number?\n          odd?\n          open-output-file\n          se",
"t-car!\n          sin\n          string\n          string->number\n          string-",
"append\n          ;; string-ci<?\n          ;; string-ci>=?\n          string-copy\n",
"          string-length\n          string-set!\n          string<?\n          strin",
"g>=?\n          string?\n          symbol->string\n          tan\n          values\n ",
"         vector->list\n          vector-length\n          vector-set!\n          wi",
"th-input-from-file\n          write\n          zero?\n          ))\n",
"",
};

static const char piclib_src_contrib_30_optional_piclib_optional[][80] = {
"(define-library (picrin optional)\n  (import (scheme base))\n\n  (define-syntax opt",
"ional\n    (syntax-rules ()\n      ((_ args default)\n       (let ((t args))\n      ",
"   (if (null? t) default (car t))))))\n\n  (define-syntax let-optionals*\n    (synt",
"ax-rules ()\n      ((_ args () body ...)\n       (begin body ...))\n      ((_ args ",
"((var default) . tail) body ...)\n       (let* ((t args)\n              (var (if (",
"null? t) default (car t)))\n              (remain (if (null? t) '() (cdr t))))\n  ",
"       (let-optionals* remain tail body ...)))\n      ((_ args rest body ...)\n   ",
"    (let ((rest args))\n         body ...))))\n\n  (export optional\n          let-o",
"ptionals*))\n",
"",
};

static const char piclib_src_contrib_30_partcont_piclib_partcont[][80] = {
"(define-library (picrin control)\n  (import (scheme base))\n\n  ; based on paper \"R",
"epresenting Monads\" (Filinski 1994)\n\n  (define m #f)\n\n  (define (abort t)\n    (l",
"et ((v (t)))                      ; (t) may update m. do not place me like (m (t",
"))\n      (m v)))\n\n  (define (reset t)\n    (let ((n m))\n      (call/cc\n       (la",
"mbda (k)\n         (set! m (lambda (r)\n                   (set! m n)\n            ",
"       (k r)))\n         (abort t)))))\n\n  (define (shift h)\n    (call/cc\n     (la",
"mbda (k)\n       (abort\n        (lambda ()\n          (h (lambda (v)\n             ",
"  (reset (lambda ()\n                        (k v))))))))))\n\n  (define-syntax res",
"et*\n    (syntax-rules ()\n      ((_ expr ...)\n       (reset (lambda () expr ...))",
")))\n\n  (define-syntax shift*\n    (syntax-rules ()\n      ((_ k expr ...)\n       (",
"shift (lambda (k) expr ...)))))\n\n  (export (rename shift* shift)\n          (rena",
"me reset* reset)))\n\n",
"",
};

static const char piclib_src_contrib_30_pretty_print_pretty_print[][80] = {
"(define-library (picrin pretty-print)\n  (import (scheme base)\n          (scheme ",
"write))\n\n  ; (reverse-string-append l) = (apply string-append (reverse l))\n\n  (d",
"efine (reverse-string-append l)\n\n    (define (rev-string-append l i)\n      (if (",
"pair? l)\n          (let* ((str (car l))\n                 (len (string-length str",
"))\n                 (result (rev-string-append (cdr l) (+ i len))))\n            ",
"(let loop ((j 0) (k (- (- (string-length result) i) len)))\n              (if (< ",
"j len)\n                  (begin\n                    (string-set! result k (strin",
"g-ref str j))\n                    (loop (+ j 1) (+ k 1)))\n                  resu",
"lt)))\n          (make-string i)))\n\n    (rev-string-append l 0))\n\n  ;; We define ",
"a pretty printer for Scheme S-expressions (sexp). While\n  ;; Petite Scheme suppo",
"rts that by its own, mzscheme does not. If you\n  ;; get a sexp (like from proof-",
"to-expr) prefix it with a call to spp and\n  ;; the output is nicely formated to ",
"fit into pp-width many columns:\n  ;;\n  ;;  (spp (proof-to-expr (current-proof)))",
"\n  ;;\n\n  (define pp-width 80)\n\n  ;;\"genwrite.scm\" generic write used by pretty-p",
"rint and truncated-print.\n  ;; Copyright (c) 1991, Marc Feeley\n  ;; Author: Marc",
" Feeley (feeley@iro.umontreal.ca)\n  ;; Distribution restrictions: none\n  ;;\n  ;;",
" Modified for Minlog by Stefan Schimanski <schimans@math.lmu.de>\n  ;; Taken from",
" slib 2d6, genwrite.scm and pp.scm\n\n  (define genwrite:newline-str (make-string ",
"1 #\\newline))\n\n  (define (generic-write obj display? width output)\n\n    (define ",
"(read-macro? l)\n      (define (length1? l) (and (pair? l) (null? (cdr l))))\n    ",
"  (let ((head (car l)) (tail (cdr l)))\n        (case head\n          ((quote quas",
"iquote unquote unquote-splicing) (length1? tail))\n          (else               ",
"                         #f))))\n\n    (define (read-macro-body l)\n      (cadr l))",
"\n\n    (define (read-macro-prefix l)\n      (let ((head (car l)) (tail (cdr l)))\n ",
"       (case head\n          ((quote)            \"'\")\n          ((quasiquote)    ",
"   \"`\")\n          ((unquote)          \",\")\n          ((unquote-splicing) \",@\")))",
")\n\n    (define (out str col)\n      (and col (output str) (+ col (string-length s",
"tr))))\n\n    (define (wr obj col)\n\n      (define (wr-lst l col)\n        (if (pair",
"? l)\n            (let loop ((l (cdr l))\n                       (col (and col (wr",
" (car l) (out \"(\" col)))))\n              (cond ((not col) col)\n                 ",
"   ((pair? l)\n                     (loop (cdr l) (wr (car l) (out \" \" col))))\n  ",
"                  ((null? l) (out \")\" col))\n                    (else      (out ",
"\")\" (wr l (out \" . \" col))))))\n            (out \"()\" col)))\n\n      (define (wr-e",
"xpr expr col)\n        (if (read-macro? expr)\n            (wr (read-macro-body ex",
"pr) (out (read-macro-prefix expr) col))\n            (wr-lst expr col)))\n\n      (",
"cond ((pair? obj)        (wr-expr obj col))\n            ((null? obj)        (wr-",
"lst obj col))\n            ((vector? obj)      (wr-lst (vector->list obj) (out \"#",
"\" col)))\n            ((boolean? obj)     (out (if obj \"#t\" \"#f\") col))\n         ",
"   ((number? obj)      (out (number->string obj) col))\n            ((symbol? obj",
")      (out (symbol->string obj) col))\n            ((procedure? obj)   (out \"#[p",
"rocedure]\" col))\n            ((string? obj)      (if display?\n                  ",
"                  (out obj col)\n                                    (let loop ((",
"i 0) (j 0) (col (out \"\\\"\" col)))\n                                      (if (and ",
"col (< j (string-length obj)))\n                                          (let ((",
"c (string-ref obj j)))\n                                            (if (or (char",
"=? c #\\\\)\n                                                    (char=? c #\\\"))\n  ",
"                                              (loop j\n                          ",
"                            (+ j 1)\n                                            ",
"          (out \"\\\\\"\n                                                           (",
"out (substring obj i j)\n                                                        ",
"        col)))\n                                                (loop i (+ j 1) c",
"ol)))\n                                          (out \"\\\"\"\n                      ",
"                         (out (substring obj i j) col))))))\n            ((char? ",
"obj)        (if display?\n                                    (out (make-string 1",
" obj) col)\n                                    (out (case obj\n                  ",
"                         ((#\\space)   \"space\")\n                                 ",
"          ((#\\newline) \"newline\")\n                                           (el",
"se        (make-string 1 obj)))\n                                         (out \"#",
"\\\\\" col))))\n            ((input-port? obj)  (out \"#[input-port]\" col))\n         ",
"   ((output-port? obj) (out \"#[output-port]\" col))\n            ((eof-object? obj",
")  (out \"#[eof-object]\" col))\n            (else               (out \"#[unknown]\" ",
"col))))\n\n    (define (pp obj col)\n\n      (define (spaces n col)\n        (if (> n",
" 0)\n            (if (> n 7)\n                (spaces (- n 8) (out \"        \" col)",
")\n                (out (substring \"        \" 0 n) col))\n            col))\n\n     ",
" (define (indent to col)\n        (and col\n             (if (< to col)\n          ",
"       (and (out genwrite:newline-str col) (spaces to 0))\n                 (spac",
"es (- to col) col))))\n\n      (define pp-list #f)\n      (define pp-expr #f)\n     ",
" (define pp-call #f)\n      (define pp-down #f)\n      (define pp-general #f)\n    ",
"  (define pp-width #f)\n      (define pp-expr-list #f)\n\n      (define indent-gene",
"ral #f)\n      (define max-expr-width #f)\n      (define max-call-head-width #f)\n ",
"     (define style #f)\n\n      (define pr\n        (lambda (obj col extra pp-pair)",
"\n          (if (or (pair? obj) (vector? obj)) ; may have to split on multiple li",
"nes\n              (let ((result '())\n                    (left (min (+ (- (- wid",
"th col) extra) 1) max-expr-width)))\n                (generic-write obj display? ",
"#f\n                               (lambda (str)\n                                ",
" (set! result (cons str result))\n                                 (set! left (- ",
"left (string-length str)))\n                                 (> left 0)))\n       ",
"         (if (> left 0)        ; all can be printed on one line\n                ",
"    (out (reverse-string-append result) col)\n                    (if (pair? obj)",
"\n                        (pp-pair obj col extra)\n                        (pp-lis",
"t (vector->list obj) (out \"#\" col) extra pp-expr))))\n              (wr obj col))",
"))\n\n      (set! pp-expr\n        (lambda (expr col extra)\n          (if (read-mac",
"ro? expr)\n              (pr (read-macro-body expr)\n                  (out (read-",
"macro-prefix expr) col)\n                  extra\n                  pp-expr)\n     ",
"         (let ((head (car expr)))\n                (if (symbol? head)\n           ",
"         (let ((proc (style head)))\n                      (if proc\n             ",
"             (proc expr col extra)\n                          (if (> (string-leng",
"th (symbol->string head))\n                                 max-call-head-width)\n",
"                              (pp-general expr col extra #f #f #f pp-expr)\n     ",
"                         (pp-call expr col extra pp-expr))))\n                   ",
" (pp-list expr col extra pp-expr))))))\n\n                                        ",
"; (head item1\n                                        ;       item2\n            ",
"                            ;       item3)\n      (set! pp-call\n        (lambda (",
"expr col extra pp-item)\n          (let ((col* (wr (car expr) (out \"(\" col))))\n  ",
"          (and col\n                 (pp-down (cdr expr) col* (+ col* 1) extra pp",
"-item)))))\n\n                                        ; (item1\n                   ",
"                     ;  item2\n                                        ;  item3)\n",
"      (set! pp-list\n        (lambda (l col extra pp-item)\n          (let ((col (",
"out \"(\" col)))\n            (pp-down l col col extra pp-item))))\n\n      (set! pp-",
"down\n        (lambda (l col1 col2 extra pp-item)\n          (let loop ((l l) (col",
" col1))\n            (and col\n                 (cond ((pair? l)\n                 ",
"       (let ((rest (cdr l)))\n                          (let ((extra (if (null? r",
"est) (+ extra 1) 0)))\n                            (loop rest\n                   ",
"               (pr (car l) (indent col2 col) extra pp-item)))))\n                ",
"       ((null? l)\n                        (out \")\" col))\n                       ",
"(else\n                        (out \")\"\n                             (pr l\n      ",
"                           (indent col2 (out \".\" (indent col2 col)))\n           ",
"                      (+ extra 1)\n                                 pp-item))))))",
"))\n\n      (set! pp-general\n        (lambda (expr col extra named? pp-1 pp-2 pp-3",
")\n\n          (define (tail3 rest col1 col2)\n            (pp-down rest col2 col1 ",
"extra pp-3))\n\n          (define (tail2 rest col1 col2 col3)\n            (if (and",
" pp-2 (pair? rest))\n                (let* ((val1 (car rest))\n                   ",
"    (rest (cdr rest))\n                       (extra (if (null? rest) (+ extra 1)",
" 0)))\n                  (tail3 rest col1 (pr val1 (indent col3 col2) extra pp-2)",
"))\n                (tail3 rest col1 col2)))\n\n          (define (tail1 rest col1 ",
"col2 col3)\n            (if (and pp-1 (pair? rest))\n                (let* ((val1 ",
"(car rest))\n                       (rest (cdr rest))\n                       (ext",
"ra (if (null? rest) (+ extra 1) 0)))\n                  (tail2 rest col1 (pr val1",
" (indent col3 col2) extra pp-1) col3))\n                (tail2 rest col1 col2 col",
"3)))\n\n          (let* ((head (car expr))\n                 (rest (cdr expr))\n    ",
"             (col* (wr head (out \"(\" col))))\n            (if (and named? (pair? ",
"rest))\n                (let* ((name (car rest))\n                       (rest (cd",
"r rest))\n                       (col** (wr name (out \" \" col*))))\n              ",
"    (tail1 rest (+ col indent-general) col** (+ col** 1)))\n                (tail",
"1 rest (+ col indent-general) col* (+ col* 1))))))\n\n      (set! pp-expr-list\n   ",
"     (lambda (l col extra)\n          (pp-list l col extra pp-expr)))\n\n      (def",
"ine (pp-LAMBDA expr col extra)\n        (pp-general expr col extra #f pp-expr-lis",
"t #f pp-expr))\n\n      (define (pp-IF expr col extra)\n        (pp-general expr co",
"l extra #f pp-expr #f pp-expr))\n\n      (define (pp-COND expr col extra)\n        ",
"(pp-call expr col extra pp-expr-list))\n\n      (define (pp-CASE expr col extra)\n ",
"       (pp-general expr col extra #f pp-expr #f pp-expr-list))\n\n      (define (p",
"p-AND expr col extra)\n        (pp-call expr col extra pp-expr))\n\n      (define (",
"pp-LET expr col extra)\n        (let* ((rest (cdr expr))\n               (named? (",
"and (pair? rest) (symbol? (car rest)))))\n          (pp-general expr col extra na",
"med? pp-expr-list #f pp-expr)))\n\n      (define (pp-BEGIN expr col extra)\n       ",
" (pp-general expr col extra #f #f #f pp-expr))\n\n      (define (pp-DO expr col ex",
"tra)\n        (pp-general expr col extra #f pp-expr-list pp-expr-list pp-expr))\n\n",
"                                        ; define formatting style (change these ",
"to suit your style)\n\n      (set! indent-general 2)\n\n      (set! max-call-head-wi",
"dth 5)\n\n      (set! max-expr-width 50)\n\n      (set! style\n        (lambda (head)",
"\n          (case head\n            ((lambda let* letrec define) pp-LAMBDA)\n      ",
"      ((if set!)                   pp-IF)\n            ((cond)                   ",
"   pp-COND)\n            ((case)                      pp-CASE)\n            ((and ",
"or)                    pp-AND)\n            ((let)                       pp-LET)\n",
"            ((begin)                     pp-BEGIN)\n            ((do)            ",
"            pp-DO)\n            (else                        #f))))\n\n      (pr ob",
"j col 0 pp-expr))\n\n    (if width\n        (out genwrite:newline-str (pp obj 0))\n ",
"       (wr obj 0)))\n\n  (define (pretty-print obj . opt)\n    (let ((port (if (pai",
"r? opt) (car opt) (current-output-port))))\n      (generic-write obj #f pp-width\n",
"                     (lambda (s) (display s port) #t))\n      (display \"\")))\n\n  (",
"export pretty-print))\n",
"",
};

static const char piclib_src_contrib_30_test_test[][80] = {
"(define-library (picrin test)\n  (import (scheme base)\n          (scheme write))\n",
"\n  (define test-counter 0)\n  (define counter 0)\n  (define failure-counter 0)\n\n  ",
"(define fails '())\n\n  (define (print-statistics)\n    (newline)\n    (display \"[0",
";34mTest Result: \")\n    (write (- counter failure-counter))\n    (display \" / \")\n",
"    (write counter)\n    (display \" (\")\n    (write (* (/ (- counter failure-count",
"er) counter) 100))\n    (display \"%)\")\n    (display \" [PASS/TOTAL]\")\n    (display",
" \"[0;39m\")\n    (newline)\n    (for-each\n     (lambda (fail)\n       (display fail",
"))\n     (reverse fails)))\n\n  (define (test-begin . o)\n    (set! test-counter (+ ",
"test-counter 1)))\n\n  (define (test-end . o)\n    (set! test-counter (- test-count",
"er 1))\n    (if (= test-counter 0)\n        (print-statistics)))\n\n  (define-syntax",
" test\n    (syntax-rules ()\n      ((test expected expr)\n       (test expected exp",
"r equal?))\n      ((test expected expr =)\n       (let ((res expr))\n         (disp",
"lay \"case \")\n         (write counter)\n         (if (= res expected)\n           (",
"begin\n             (display \"[0;32m PASS: \")\n             (write 'expr)\n       ",
"      (display \" equals \")\n             (write expected)\n             (display \"",
"[0;39m\")\n             (newline))\n           (begin\n             (set! failure-c",
"ounter (+ failure-counter 1))\n             (let ((out (open-output-string)))\n   ",
"            (display \" [0;31mFAIL: \" out)\n               (write 'expr out)\n    ",
"           (newline out)\n               (display \"   expected \" out)\n           ",
"    (write expected out)\n               (display \" but got \" out)\n              ",
" (write res out)\n               (display \"[0;39m\" out)\n               (newline ",
"out)\n               (let ((str (get-output-string out)))\n                 (set! ",
"fails (cons str fails))\n                 (display str)))))\n         (set! counte",
"r (+ counter 1))))))\n\n  (define-syntax test-values\n    (syntax-rules ()\n      ((",
"_ expect expr)\n       (test (call-with-values (lambda () expect) (lambda results",
" results))\n             (call-with-values (lambda () expr) (lambda results resul",
"ts))))))\n\n\n  (define (test-failure-count)\n    (length fails))\n\n  (define-syntax ",
"test-syntax-error\n    (syntax-rules ()\n      ((_) (syntax-error \"invalid use of ",
"test-syntax-error\"))))\n\n  (export test test-begin test-end test-values test-synt",
"ax-error))\n",
"",
};

static const char piclib_src_contrib_40_procedure_procedure[][80] = {
"(define-library (picrin procedure)\n  (import (scheme base))\n  (export >>\n       ",
"   <<\n          constant\n          identity)\n\n  (define identity values)\n\n  (def",
"ine (constant . args)\n    (lambda _\n      (apply values args)))\n\n  (define (>> .",
" fs)\n    (if (null? fs)\n        identity\n        (let ((f (car fs))\n            ",
"  (g (apply >> (cdr fs))))\n          (lambda args\n            (call-with-values ",
"(lambda () (apply f args))\n              (lambda args\n                (apply g a",
"rgs)))))))\n\n  (define (<< . fs)\n    (apply >> (reverse fs))))\n",
"",
};

static const char piclib_src_contrib_40_srfi_srfi_0[][80] = {
"(define-library (srfi 0)\n  (import (scheme base))\n  (export cond-expand))\n",
"",
};

static const char piclib_src_contrib_40_srfi_srfi_1[][80] = {
"(define-library (srfi 1)\n  (import (scheme base)\n          (scheme cxr))\n\n  ;; #",
" Constructors\n  ;; cons list\n  ;; xcons cons* make-list list-tabulate\n  ;; list-",
"copy circular-list iota\n  (define (xcons a b)\n    (cons b a))\n\n  ;; means for in",
"ter-referential definition\n  (define append-reverse #f)\n\n  (define (cons* x . ar",
"gs)\n    (let rec ((acc '()) (x x) (lst args))\n      (if (null? lst)\n          (a",
"ppend-reverse acc x)\n          (rec (cons x acc) (car lst) (cdr lst)))))\n\n  (def",
"ine (list-tabulate n init-proc)\n    (let rec ((acc '()) (n (- n 1)))\n      (if (",
"zero? n)\n          (cons n acc)\n          (rec (cons n acc) (- n 1)))))\n\n  (defi",
"ne (circular-list elt . args)\n    (let ((lst (cons elt args)))\n      (let rec ((",
"l lst))\n        (if (null? (cdr l))\n            (set-cdr! l lst)\n            (re",
"c (cdr l))))\n      lst))\n\n  (define (iota count . lst)\n    (let ((start (if (pai",
"r? lst) (car lst) 0))\n          (step (if (and (pair? lst) (pair? (cdr lst)))\n  ",
"                  (cadr lst) 1)))\n      (let rec ((count (- count 1)) (acc '()))",
"\n        (if (zero? count)\n            (cons start acc)\n            (rec (- coun",
"t 1)\n                 (cons (+ start (* count step)) acc))))))\n\n  (export cons l",
"ist xcons cons* make-list list-tabulate list-copy circular-list iota)\n\n  ;; # Pr",
"edicates\n  ;; pair? null?\n  ;; proper-list? circular-list? dotted-list?\n  ;; not",
"-pair? null-list?\n  ;; list=\n  (define (not-pair? x)\n    (not (pair? x)))\n  ;; d",
"etects circular list using Floyd's cycle-finding algorithm\n  (define (circular-l",
"ist? x)\n    (let rec ((rapid x) (local x))\n      (if (and (pair? rapid) (pair? (",
"cdr rapid)))\n          (if (eq? (cddr rapid) (cdr local))\n              #t\n     ",
"         (rec (cddr rapid) (cdr local)))\n          #f)))\n\n  (define proper-list?",
" list?)\n\n  (define (dotted-list? x)\n    (and (pair? x)\n         (not (proper-lis",
"t? x))\n         (not (circular-list? x))))\n\n  (define (null-list? x)\n    (cond (",
"(pair? x) #f)\n          ((null? x) #t)\n          (else (error \"null-list?: argum",
"ent out of domain\" x))))\n\n  (define (list= elt= . lists)\n    (or (null? lists)\n ",
"       (let rec1 ((list1 (car lists)) (others (cdr lists)))\n          (or (null?",
" others)\n              (let ((list2 (car others))\n                    (others (c",
"dr others)))\n                (if (eq? list1 list2)\n                    (rec1 lis",
"t2 others)\n                    (let rec2 ((l1 list1) (l2 list2))\n               ",
"       (if (null-list? l1)\n                          (and (null-list? l2)\n      ",
"                         (rec1 list2 others))\n                          (and (no",
"t (null-list? l2))\n                               (elt= (car l1) (car l2))\n     ",
"                          (rec2 (cdr l1) (cdr l2)))))))))))\n\n  (export pair? nul",
"l? not-pair? proper-list? circular-list? null-list? list=)\n\n  ;; # Selectors\n  ;",
"; car cdr ... cddadr cddddr list-ref\n  ;; first second third fourth fifth sixth ",
"seventh eighth ninth tenth\n  ;; car+cdr\n  ;; take drop\n  ;; take-right drop-righ",
"t\n  ;; take! drop-right!\n  ;; split-at split-at!\n  ;; last last-pair\n  (define (",
"car+cdr pair)\n    (values (car pair) (cdr pair)))\n\n  (define (take x i)\n    (if ",
"(zero? i)\n        '()\n        (cons (car x)\n              (take (cdr x) (- i 1))",
")))\n\n  (define (drop x i)\n    (if (zero? i)\n        x\n        (drop (cdr x) (- i",
" 1))))\n\n  (define (take-right flist i)\n    (let ((len (length flist)))\n      (dr",
"op flist (- len i))))\n\n  (define (drop-right flist i)\n    (let ((len (length fli",
"st)))\n      (take flist (- len i))))\n\n  (define (take! x i)\n    (let rec ((lis x",
") (n (- i 1)))\n      (if (zero? n)\n          (begin (set-cdr! lis '()) x)\n      ",
"    (rec (cdr lis) (- n 1)))))\n\n  (define (drop-right! flist i)\n    (let ((lead ",
"(drop flist i)))\n      (if (not-pair? lead)\n          '()\n          (let rec ((l",
"is1 flist) (lis2 (cdr lead)))\n            (if (pair? lis2)\n                (rec ",
"(cdr lis1) (cdr lis2))\n                (begin (set-cdr! lis1 '()) flist))))))\n\n ",
" (define (split-at x i)\n    (values (take x i) (drop x i)))\n\n  (define (split-at",
"! x i)\n    (values (take! x i) (drop x i)))\n\n  (define (last pair)\n    (car (tak",
"e-right pair 1)))\n\n  (define (last-pair pair)\n    (take-right pair 1))\n\n  (defin",
"e first car)\n  (define second cadr)\n  (define third caddr)\n  (define fourth cadd",
"dr)\n  (define (fifth pair)\n    (list-ref pair 4))\n  (define (sixth pair)\n    (li",
"st-ref pair 5))\n  (define (seventh pair)\n    (list-ref pair 6))\n  (define (eight",
"h pair)\n    (list-ref pair 7))\n  (define (ninth pair)\n    (list-ref pair 8))\n  (",
"define (tenth pair)\n    (list-ref pair 9))\n\n\n  (export car cdr car+cdr list-ref\n",
"          caar cadr cdar cddr caaar caadr cadar caddr cdaar cdadr cddar cdddr\n  ",
"        caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr cdaaar cdaadr\n  ",
"        cdadar cdaddr cddaar cddadr cdddar cddddr\n          first second third f",
"ourth fifth sixth seventh eighth ninth tenth\n          take drop take-right drop",
"-right take! drop-right!\n          split-at split-at! last last-pair)\n\n  ;; # Mi",
"scellaneous\n  ;; length length+\n  ;; append concatenate reverse\n  ;; append! con",
"catenate! reverse!\n  ;; append-reverse append-reverse!\n  ;; zip unzip1 unzip2 un",
"zip3 unzip4 unzip5\n  ;; count\n  (define (length+ lst)\n    (if (not (circular-lis",
"t? lst))\n        (length lst)))\n\n  (define (concatenate lists)\n    (apply append",
" lists))\n\n  (define (append! . lists)\n    (if (null? lists)\n        '()\n        ",
"(let rec ((lst lists))\n          (if (not-pair? (cdr lst))\n              (car ls",
"t)\n              (begin (set-cdr! (last-pair (car lst)) (cdr lst))\n             ",
"        (rec (cdr lst)))))))\n\n  (define (concatenate! lists)\n    (apply append! ",
"lists))\n\n  (define (reverse! list)\n    (let rec ((lst list) (acc '()))\n      (if",
" (null? lst)\n          acc\n          (let ((rst (cdr lst)))\n            (set-cdr",
"! lst acc)\n            (rec rst lst)))))\n\n  (set! append-reverse\n        (lambda",
" (rev-head tail)\n          (if (null? rev-head)\n              tail\n             ",
" (append-reverse (cdr rev-head) (cons (car rev-head) tail)))))\n\n  (define (appen",
"d-reverse! rev-head tail)\n    (let ((rst (cdr rev-head)))\n      (if (null? rev-h",
"ead)\n          tail\n          (begin (set-cdr! rev-head tail)\n                 (",
"append-reverse! rst rev-head)))))\n\n  (define (zip . lists)\n    (apply map list l",
"ists))\n\n  (define (unzip1 list)\n    (map first list))\n\n  (define (unzip2 list)\n ",
"   (values (map first list)\n            (map second list)))\n\n  (define (unzip3 l",
"ist)\n    (values (map first list)\n            (map second list)\n            (map",
" third list)))\n\n  (define (unzip4 list)\n    (values (map first list)\n           ",
" (map second list)\n            (map third list)\n            (map fourth list)))\n",
"\n  (define (unzip5 list)\n    (values (map first list)\n            (map second li",
"st)\n            (map third list)\n            (map fourth list)\n            (map ",
"fifth list)))\n\n  (define (count pred . clists)\n    (let rec ((tflst (apply map p",
"red clists)) (n 0))\n      (if (null? tflst)\n          n\n          (rec (cdr tfls",
"t) (if (car tflst) (+ n 1) n)))))\n\n  (export length length+\n          append app",
"end! concatenate concatenate!\n          reverse reverse! append-reverse append-r",
"everse!\n          zip unzip1 unzip2 unzip3 unzip4 unzip5\n          count)\n\n  ;; ",
"# Fold, unfold & map\n  ;; map for-each\n  ;; fold unfold pair-fold reduce\n  ;; fo",
"ld-right unfold-right pair-fold right reduce-right\n  ;; append-map append-map!\n ",
" ;; map! pair-for-each filter-map map-in-order\n\n  ;; means for inter-referential",
" definition\n  (define every #f)\n\n  (define (fold kons knil clist . clists)\n    (",
"if (null? clists)\n        (let rec ((acc knil) (clist clist))\n          (if (nul",
"l? clist)\n              acc\n              (rec (kons (car clist) acc) (cdr clist",
"))))\n        (let rec ((acc knil) (clists (cons clist clists)))\n          (if (e",
"very pair? clists)\n              (rec (apply kons (append (map car clists) (list",
" acc)))\n                   (map cdr clists))\n              acc))))\n\n  (define (f",
"old-right kons knil clist . clists)\n    (if (null? clists)\n        (let rec ((cl",
"ist clist) (cont values))\n          (if (null? clist)\n              (cont knil)\n",
"              (rec (cdr clist) (lambda (x) (cont (kons (car clist) x))))))\n     ",
"   (let rec ((clists (cons clist clists)) (cont values))\n          (if (every pa",
"ir? clists)\n              (rec (map cdr clists)\n                   (lambda (x)\n ",
"                    (cont (apply kons (append (map car clists) (list x))))))\n   ",
"           (cont knil)))))\n\n  (define (pair-fold kons knil clist . clists)\n    (",
"if (null? clists)\n        (let rec ((acc knil) (clist clist))\n          (if (nul",
"l? clist)\n              acc\n              (let ((tail (cdr clist)))\n            ",
"    (rec (kons clist acc) tail))))\n        (let rec ((acc knil) (clists (cons cl",
"ist clists)))\n          (if (every pair? clists)\n              (let ((tail (map ",
"cdr clists)))\n                (rec (apply kons (append clists (list acc)))\n     ",
"                tail))\n              acc))))\n\n  (define (pair-fold-right kons kn",
"il clist . clists)\n    (if (null? clists)\n        (let rec ((clist clist) (cont ",
"values))\n          (if (null? clist)\n              (cont knil)\n                (",
"rec (cdr clist) (lambda (x) (cont (kons clist x))))))\n        (let rec ((clists ",
"(cons clist clists)) (cont values))\n          (if (every pair? clists)\n         ",
"     (let ((tail (map cdr clists)))\n                (rec tail\n                  ",
"   (lambda (x)\n                       (cont (apply kons (append clists (list x))",
")))))\n              (cont knil)))))\n\n  (define (reduce f ridentity list)\n    (if",
" (null? list)\n        ridentity\n        (fold f (car list) (cdr list))))\n\n  (def",
"ine (reduce-right f ridentity list)\n    (fold-right f ridentity list))\n\n  (defin",
"e (unfold p f g seed . tail-gen)\n    (let ((tail-gen (if (null? tail-gen)\n      ",
"                  (lambda (x) '())\n                        (car tail-gen))))\n   ",
"   (let rec ((seed seed) (cont values))\n        (if (p seed)\n            (cont (",
"tail-gen seed))\n            (rec (g seed) (lambda (x) (cont (cons (f seed) x))))",
"))))\n\n  (define (unfold-right p f g seed . tail)\n    (let rec ((seed seed) (lst ",
"tail))\n      (if (p seed)\n          lst\n          (rec (g seed) (cons (f seed) l",
"st)))))\n\n  (define (append-map f . clists)\n    (apply append (apply map f clists",
")))\n\n  (define (append-map! f . clists)\n    (apply append! (apply map f clists))",
")\n\n  (define (pair-for-each f clist . clists)\n    (if (null? clist)\n        (let",
" rec ((clist clist))\n          (if (pair? clist)\n              (begin (f clist) ",
"(rec (cdr clist)))))\n        (let rec ((clists (cons clist clists)))\n          (",
"if (every pair? clists)\n              (begin (apply f clists) (rec (map cdr clis",
"ts)))))))\n\n  (define (map! f list . lists)\n    (if (null? lists)\n        (pair-f",
"or-each (lambda (x) (set-car! x (f (car x)))) list)\n        (let rec ((list list",
") (lists lists))\n          (if (pair? list)\n              (let ((head (map car l",
"ists))\n                    (rest (map cdr lists)))\n                (set-car! lis",
"t (apply f (car list) head))\n                (rec (cdr list) rest)))))\n    list)",
"\n\n  (define (map-in-order f clist . clists)\n    (if (null? clists)\n        (let ",
"rec ((clist clist) (acc '()))\n          (if (null? clist)\n              (reverse",
"! acc)\n              (rec (cdr clist) (cons (f (car clist)) acc))))\n        (let",
" rec ((clists (cons clist clists)) (acc '()))\n          (if (every pair? clists)",
"\n              (rec (map cdr clists)\n                   (cons* (apply f (map car",
" clists)) acc))\n              (reverse! acc)))))\n\n  (define (filter-map f clist ",
". clists)\n    (let recur ((l (apply map f clist clists)))\n      (cond ((null? l)",
" '())\n            ((car l)   (cons (car l) (recur (cdr l))))\n            (else  ",
"    (recur (cdr l))))))\n\n  (export map for-each\n          fold unfold pair-fold ",
"reduce\n          fold-right unfold-right pair-fold-right reduce-right\n          ",
"append-map append-map!\n          map! pair-for-each filter-map map-in-order)\n\n  ",
";; # Filtering & partitioning\n  ;; filter partition remove\n  ;; filter! partitio",
"n! remove!\n  (define (filter pred list)\n    (let ((pcons (lambda (v acc) (if (pr",
"ed v) (cons v acc) acc))))\n      (reverse (fold pcons '() list))))\n\n  (define (r",
"emove pred list)\n    (filter (lambda (x) (not (pred x))) list))\n\n  (define (part",
"ition pred list)\n    (values (filter pred list)\n            (remove pred list)))",
"\n\n  (define (filter! pred list)\n    (let rec ((lst list))\n      (if (null? lst)\n",
"          lst\n          (if (pred (car lst))\n              (begin (set-cdr! lst ",
"(rec (cdr lst)))\n                     lst)\n              (rec (cdr lst))))))\n\n  ",
"(define (remove! pred list)\n    (filter! (lambda (x) (not (pred x))) list))\n\n  (",
"define (partition! pred list)\n    (values (filter! pred list)\n            (remov",
"e! pred list)))\n\n  (export filter partition remove\n          filter! partition! ",
"remove!)\n\n  ;; # Searching\n  ;; member memq memv\n  ;; find find-tail\n  ;; any ev",
"ery\n  ;; list-index\n  ;; take-while drop-while take-while!\n  ;; span break span!",
" break!\n\n  (define (find-tail pred list)\n    (if (null? list)\n        #f\n       ",
" (if (pred (car list))\n            list\n            (find-tail pred (cdr list)))",
"))\n\n  (define (find pred list)\n    (let ((tail (find-tail pred list)))\n      (if",
" tail\n          (car tail)\n          #f)))\n\n  (define (take-while pred clist)\n  ",
"  (let rec ((clist clist) (cont values))\n      (if (null? clist)\n          (cont",
" '())\n          (if (pred (car clist))\n              (rec (cdr clist)\n          ",
"         (lambda (x) (cont (cons (car clist) x))))\n              (cont '())))))\n",
"\n  (define (take-while! pred clist)\n    (let rec ((clist clist))\n      (if (null",
"? clist)\n          '()\n          (if (pred (car clist))\n              (begin (se",
"t-cdr! clist (rec (cdr clist)))\n                     clist)\n              '())))",
")\n\n  (define (drop-while pred clist)\n    (let rec ((clist clist))\n      (if (nul",
"l? clist)\n          '()\n          (if (pred (car clist))\n              (rec (cdr",
" clist))\n              clist))))\n\n  (define (span pred clist)\n    (values (take-",
"while pred clist)\n            (drop-while pred clist)))\n\n  (define (span! pred c",
"list)\n    (values (take-while! pred clist)\n            (drop-while pred clist)))",
"\n\n  (define (break pred clist)\n    (values (take-while (lambda (x) (not (pred x)",
")) clist)\n            (drop-while (lambda (x) (not (pred x))) clist)))\n\n  (defin",
"e (break! pred clist)\n    (values (take-while! (lambda (x) (not (pred x))) clist",
")\n            (drop-while (lambda (x) (not (pred x))) clist)))\n\n  (define (any p",
"red clist . clists)\n    (if (null? clists)\n        (let rec ((clist clist))\n    ",
"      (and (pair? clist)\n              (or (pred (car clist))\n                  ",
"(rec (cdr clist)))))\n        (let rec ((clists (cons clist clists)))\n          (",
"and (every pair? clists)\n              (or (apply pred (map car clists))\n       ",
"           (rec (map cdr clists)))))))\n\n  (set! every\n        (lambda (pred clis",
"t . clists)\n          (if (null? clists)\n              (let rec ((clist clist))\n",
"                (or (null? clist)\n                    (and (pred (car clist))\n  ",
"                      (rec (cdr clist)))))\n              (let rec ((clists (cons",
" clist clists)))\n                (or (any null? clists)\n                    (and",
" (apply pred (map car clists))\n                        (rec (map cdr clists)))))",
")))\n\n  (define (list-index pred clist . clists)\n    (if (null? clists)\n        (",
"let rec ((clist clist) (n 0))\n          (if (pair? clist)\n              (if (pre",
"d (car clist))\n                  n\n                  (rec (cdr clist) (+ n 1))))",
")\n        (let rec ((clists (cons clist clists)) (n 0))\n          (if (every pai",
"r? clists)\n              (if (apply pred (map car clists))\n                  n\n ",
"                 (rec (map cdr clists) (+ n 1)))))))\n\n  (export member memq memv",
"\n          find find-tail\n          any every\n          list-index\n          tak",
"e-while drop-while take-while!\n          span break span! break!)\n\n  ;; # Deleti",
"ng\n  ;; delete delete-duplicates\n  ;; delete! delete-duplicates!\n  (define (dele",
"te x list . =)\n    (let ((= (if (null? =) equal? (car =))))\n      (remove (lambd",
"a (a) (= x a)) list)))\n\n  (define (delete! x list . =)\n    (let ((= (if (null? =",
") equal? (car =))))\n      (remove! (lambda (a) (= x a)) list)))\n\n  (define (dele",
"te-duplicates list . =)\n    (let ((= (if (null? =) equal? (car =))))\n      (let ",
"rec ((list list) (cont values))\n        (if (null? list)\n            (cont '())\n",
"            (let* ((x (car list))\n                   (rest (cdr list))\n         ",
"          (deleted (delete x rest =)))\n              (rec deleted (lambda (y) (c",
"ont (cons x y)))))))))\n\n  (define (delete-duplicates! list . =)\n    (let ((= (if",
" (null? =) equal? (car =))))\n      (let rec ((list list) (cont values))\n        ",
"(if (null? list)\n            (cont '())\n            (let* ((x (car list))\n      ",
"             (rest (cdr list))\n                   (deleted (delete! x list =)))\n",
"              (rec deleted (lambda (y) (cont (cons x y)))))))))\n\n  (export delet",
"e delete-duplicates\n          delete! delete-duplicates!)\n\n  ;; # Association li",
"sts\n  ;; assoc assq assv\n  ;; alist-cons alist-copy\n  ;; alist-delete alist-dele",
"te!\n  (define (alist-cons key datum alist)\n    (cons (cons key datum) alist))\n\n ",
" (define (alist-copy alist)\n    (map (lambda (elt) (cons (car elt) (cdr elt))) a",
"list))\n\n  (define (alist-delete key alist . =)\n    (let ((= (if (null? =) equal?",
" (car =))))\n      (remove (lambda (x) (= key (car x))) alist)))\n\n  (define (alis",
"t-delete! key alist . =)\n    (let ((= (if (null? =) equal? (car =))))\n      (rem",
"ove! (lambda (x) (= key (car x))) alist)))\n\n  (export assoc assq assv\n          ",
"alist-cons alist-copy\n          alist-delete alist-delete!)\n\n  ;; # Set operatio",
"ns on lists\n  ;; lset<= lset= lset-adjoin\n  ;; lset-union lset-union!\n  ;; lset-",
"intersection lset-intersection!\n  ;; lset-difference lset-difference!\n  ;; lset-",
"xor lset-xor!\n  ;; lset-diff+intersenction lset-diff+intersection!\n  (define (ls",
"et<= = . lists)\n    (or (null? lists)\n        (let rec ((head (car lists)) (rest",
" (cdr lists)))\n          (or (null? rest)\n              (let ((next (car rest)) ",
"(rest (cdr rest)))\n                (and (or (eq? head next)\n                    ",
"     (every (lambda (x) (member x next =)) head))\n                     (rec next",
" rest)))))))\n\n  (define (lset= = . lists)\n    (or (null? lists)\n        (let rec",
" ((head (car lists)) (rest (cdr lists)))\n          (or (null? rest)\n            ",
"  (let ((next (car rest)) (rest (cdr rest)))\n                (and (or (eq? head ",
"next)\n                         (and (every (lambda (x) (member x next =)) head)\n",
"                              (every (lambda (x) (member x head =)) next))\n     ",
"                    (rec next rest))))))))\n\n  (define (lset-adjoin = list . elts",
")\n    (let rec ((list list) (elts elts))\n      (if (null? elts)\n          list\n ",
"         (if (member (car elts) list)\n              (rec list (cdr elts))\n      ",
"        (rec (cons (car elts) list) (cdr elts))))))\n\n  (define (lset-union = . l",
"ists)\n    (if (null? lists)\n        lists\n        (let rec ((head (car lists)) (",
"rest (cdr lists)))\n          (if (null? rest)\n              head\n              (",
"let ((next (car rest)) (rest (cdr rest)))\n                (if (eq? head next)\n  ",
"                  (rec head rest)\n                    (rec (apply lset-adjoin = ",
"head next) rest)))))))\n\n  (define (lset-intersection = . lists)\n    (if (null? l",
"ists)\n        lists\n        (let rec ((head (car lists)) (rest (cdr lists)))\n   ",
"       (if (null? rest)\n              head\n              (let ((next (car rest))",
" (rest (cdr rest)))\n                (if (eq? head next)\n                    (rec",
" head rest)\n                    (rec (filter (lambda (x) (member x next =)) head",
")\n                         rest)))))))\n\n  (define (lset-difference = list . list",
"s)\n    (let rec ((head list) (rest lists))\n      (if (null? rest)\n          head",
"\n          (let ((next (car rest)) (rest (cdr rest)))\n            (if (eq? head ",
"next)\n                '()\n                (rec (remove (lambda (x) (member x nex",
"t =)) head)\n                     rest))))))\n\n  (define (lset-xor = . lists)\n    ",
"(if (null? lists)\n        lists\n        (let rec ((head (car lists)) (rest (cdr ",
"lists)))\n          (if (null? rest)\n              head\n              (let ((next",
" (car rest)) (rest (cdr rest)))\n                (if (eq? head next)\n            ",
"        '()\n                    (rec (append (remove (lambda (x) (member x next ",
"=)) head)\n                                 (remove (lambda (x) (member x head =)",
") next))\n                         rest)))))))\n\n  (define (lset-diff+intersection",
" = list . lists)\n    (values (apply lset-difference = list lists)\n            (l",
"set-intersection = list (apply lset-union lists))))\n\n  (define (lset-adjoin! = l",
"ist . elts)\n    (let rec ((list list) (elts elts))\n      (if (null? elts)\n      ",
"    list\n          (if (member (car elts) list)\n              (rec list (cdr elt",
"s))\n              (let ((tail (cdr elts)))\n                (set-cdr! elts list)\n",
"                (rec elts tail))))))\n\n  (define (lset-union! = . lists)\n    (let",
"rec ((adjoin\n              (lambda (lst1 lst2)\n                (if (null? lst2)\n",
"                    lst1\n                    (if (member (car lst2) lst1 =)\n    ",
"                    (adjoin lst1 (cdr lst2))\n                        (let ((tail",
" (cdr lst2)))\n                          (set-cdr! lst2 lst1)\n                   ",
"       (adjoin lst2 tail)))))))\n      (if (null? lists)\n          lists\n        ",
"  (let rec ((head (car lists)) (rest (cdr lists)))\n            (if (null? rest)\n",
"                head\n                (let ((next (car rest)) (rest (cdr rest)))\n",
"                  (if (eq? head next)\n                      (rec head rest)\n    ",
"                  (rec (adjoin head next) rest))))))))\n\n  (define (lset-intersec",
"tion! = . lists)\n    (if (null? lists)\n        lists\n        (let rec ((head (ca",
"r lists)) (rest (cdr lists)))\n          (if (null? rest)\n              head\n    ",
"          (let ((next (car rest)) (rest (cdr rest)))\n                (if (eq? he",
"ad next)\n                    (rec head rest)\n                    (rec (filter! (",
"lambda (x) (member x next =)) head)\n                         rest)))))))\n\n  (def",
"ine (lset-difference! = list . lists)\n    (let rec ((head list) (rest lists))\n  ",
"    (if (null? rest)\n          head\n          (let ((next (car rest)) (rest (cdr",
" rest)))\n            (if (eq? head next)\n                '()\n                (re",
"c (remove! (lambda (x) (member x next =)) head)\n                     rest))))))\n",
"\n  (define (lset-xor! = . lists)\n    (if (null? lists)\n        lists\n        (le",
"t rec ((head (car lists)) (rest (cdr lists)))\n          (if (null? rest)\n       ",
"       head\n              (let ((next (car rest)) (rest (cdr rest)))\n           ",
"     (if (eq? head next)\n                    '()\n                    (rec (appen",
"d! (remove! (lambda (x) (member x next =)) head)\n                               ",
"   (remove! (lambda (x) (member x head =)) next))\n                         rest)",
"))))))\n\n  (define (lset-diff+intersection! = list . lists)\n    (values (apply ls",
"et-difference! = list lists)\n            (lset-intersection! = list (apply lset-",
"union! lists))))\n\n  (export lset<= lset= lset-adjoin\n          lset-union lset-u",
"nion!\n          lset-intersection lset-intersection!\n          lset-difference l",
"set-difference!\n          lset-xor lset-xor!\n          lset-diff+intersection ls",
"et-diff+intersection!)\n\n  ;; # Primitive side-effects\n  ;; set-car! set-cdr!\n  (",
"export set-car! set-cdr!))\n",
"",
};

static const char piclib_src_contrib_40_srfi_srfi_8[][80] = {
"(define-library (srfi 8)\n  (import (scheme base))\n\n  (define-syntax receive\n    ",
"(syntax-rules ()\n      ((receive formals expression body ...)\n       (call-with-",
"values (lambda () expression)\n         (lambda formals body ...)))))\n\n    (expor",
"t receive))\n",
"",
};

static const char piclib_src_contrib_40_srfi_srfi_17[][80] = {
"(define-library (srfi 17)\n\n  (import (except (scheme base) set!)\n          (pref",
"ix (only (scheme base) set!) %)\n          (except (picrin base) set!)\n          ",
"(srfi 1)\n          (srfi 8))\n\n  (define-syntax set!\n    (syntax-rules ()\n      (",
"(_ (proc args ...) val)\n       ((setter proc) args ... val))\n      ((_ var val)\n",
"       (%set! var val))))\n\n  (define setter\n    (letrec ((setter\n              (",
"lambda (proc)\n                (let ((setter (dictionary-ref (attribute proc) '@@",
"setter)))\n                  (if setter\n                      (cdr setter)\n      ",
"                (error \"no setter found\")))))\n             (set-setter!\n        ",
"      (lambda (proc setter)\n                (dictionary-set! (attribute proc) '@",
"@setter setter))))\n      (set-setter! setter set-setter!)\n      setter))\n\n  (def",
"ine (getter-with-setter get set)\n    (let ((proc (lambda args (apply get args)))",
")\n      (set! (setter proc) set)\n      proc))\n\n  (set! (setter car) set-car!)\n  ",
"(set! (setter cdr) set-cdr!)\n  (set! (setter vector-ref) vector-set!)\n  (set! (s",
"etter string-ref) string-set!)\n  (set! (setter bytevector-u8-ref) bytevector-u8-",
"set!)\n  (set! (setter list-ref) list-set!)\n\n  (export set!\n          setter\n    ",
"      getter-with-setter))\n",
"",
};

static const char piclib_src_contrib_40_srfi_srfi_26[][80] = {
"(define-library (srfi 26)\n  (import (scheme base)\n	  (picrin macro)\n	  (srfi 1))",
"\n\n  (define-macro cut%\n    (ir-macro-transformer\n     (lambda (form inject compa",
"re?)\n       (let ((slots (second form))\n	     (combi (third form))\n	     (se (cd",
"ddr form)))\n	 (cond ((null? se)\n		`(lambda ,slots ((begin ,(car combi)) ,@(cdr c",
"ombi))))\n	       ((and (symbol? (car se))\n		     (compare? (car se) '<...>))\n		`",
"(lambda (,@slots . rest-slot) (apply ,@combi rest-slot)))\n	       ((and (symbol?",
" (car se))\n		     (compare? (car se) '<>))\n		`(cut% (,@slots x) (,@combi x) ,@(c",
"dr se)))\n	       (else `(cut% ,slots (,@combi ,(car se)) ,@(cdr se))))))))\n\n  (d",
"efine-macro cute%\n    (ir-macro-transformer\n     (lambda (form inject compare?)\n",
"       (let ((slots (second form))\n	     (binds (third form))\n	     (combi (four",
"th form))\n	     (se (cddddr form)))\n	 (cond ((null? se)\n		`(let ,binds\n		   (lam",
"bda ,slots ((begin ,(car combi)) ,@(cdr combi)))))\n	       ((and (symbol? (car s",
"e))\n		     (compare? (car se) '<...>))\n		`(let ,binds\n		   (lambda (,@slots . re",
"st-slot) (apply ,@combi rest-slot))))\n	       ((and (symbol? (car se))\n		     (c",
"ompare? (car se) '<>))\n		`(cute% (,@slots x) ,binds (,@combi x) ,@(cdr se)))\n	  ",
"     (else\n		`(cute% ,slots ((x ,(car se)) ,@binds)\n			(,@combi x) ,@(cdr se))))",
"))))\n  \n  (define-macro cut\n    (ir-macro-transformer\n     (lambda (form inject ",
"compare?)\n       `(cut% () () ,@(cdr form)))))\n\n  (define-macro cute\n    (ir-mac",
"ro-transformer\n     (lambda (form inject compare?)\n       `(cute% () () () ,@(cd",
"r form)))))\n\n  (export cut cute))\n",
"",
};

static const char piclib_src_contrib_40_srfi_srfi_43[][80] = {
"(define-library (srfi 43)\n  (import (except (scheme base) vector-map)\n          ",
"(srfi 8))\n  \n  ;; # Constructors\n  (define (vector-unfold f length . seeds)\n    ",
"(let ((seeds (if (null? seeds) '(0) seeds))\n          (vect (make-vector length)",
"))\n      (letrec ((tabulate\n                (lambda (count . args)\n             ",
"     (if (= length count)\n                      vect\n                      (rece",
"ive lst (apply f count args)\n                               (vector-set! vect co",
"unt (car lst))\n                               (apply tabulate (+ 1 count) (cdr l",
"st)))))))\n        (apply tabulate 0 seeds))))\n\n  (define (vector-unfold-right f ",
"length . seeds)\n    (let ((seeds (if (null? seeds) '(0) seeds))\n          (vect ",
"(make-vector length)))\n      (letrec ((tabulate\n                (lambda (count .",
" args)\n                  (if (< count 0)\n                      vect\n            ",
"          (receive lst (apply f count args)\n                               (vect",
"or-set! vect count (car lst))\n                               (apply tabulate (- ",
"count 1) (cdr lst)))))))\n        (apply tabulate (- length 1) seeds))))\n\n  (defi",
"ne (vector-reverse-copy vec . rst)\n    (let* ((start (if (null? rst) 0 (car rst)",
"))\n           (end (if (or (null? rst) (null? (cdr rst)))\n                    (v",
"ector-length vec)\n                    (cadr rst)))\n           (new-vect (make-ve",
"ctor (- end start))))\n      (let loop ((i (- end 1)) (count 0))\n        (if (< i",
" start)\n            new-vect\n            (begin\n              (vector-set! new-v",
"ect count (vector-ref vec i))\n              (loop (- i 1) (+ 1 count)))))))\n\n  (",
"define (vector-concatenate list-of-vectors)\n    (apply vector-append list-of-vec",
"tors))\n\n  \n  ;; # Predicates\n  (define (vector-empty? vec)\n    (zero? (vector-le",
"ngth vec)))\n\n                                        ; for the symmetry, this sh",
"ould be rather 'vector=?' than 'vector='.\n  (define (vector= elt=? . vects)\n    ",
"(letrec ((vector2=\n              (lambda (v1 v2)\n                (let ((ln1 (vec",
"tor-length v1)))\n                  (and (= ln1 (vector-length v2))\n             ",
"          (let loop ((count 0))\n                         (if (= ln1 count)\n     ",
"                        #t\n                             (and (elt=? (vector-ref ",
"v1 count)\n                                         (vector-ref v2 count))\n      ",
"                            (loop (+ 1 count))))))))))\n      (or (null? vects)\n ",
"         (let rec1 ((vect1 (car vects)) (others (cdr vects)))\n            (or (n",
"ull? others)\n                (let ((vect2 (car others))\n                      (o",
"thers (cdr others)))\n                  (if (eq? vect1 vect2)\n                   ",
"   (rec1 vect1 others)\n                      (and (vector2= vect1 vect2)\n       ",
"                    (rec1 vect2 others)))))))))\n\n  \n  ;; # Iteration\n  (define (",
"vector-fold kons knil vec . vects)\n    (let* ((vects (cons vec vects))\n         ",
"  (veclen (apply min (map vector-length vects))))\n      (let rec ((acc knil) (co",
"unt 0))\n        (if (= count veclen)\n            acc\n            (rec (apply kon",
"s count acc\n                        (map (lambda (v) (vector-ref v count)) vects",
"))\n                 (+ 1 count))))))\n\n  (define (vector-fold-right kons knil vec",
" . vects)\n    (let* ((vects (cons vec vects))\n           (veclen (apply min (map",
" vector-length vects))))\n      (let rec ((acc knil) (count (- veclen 1)))\n      ",
"  (if (< count 0)\n            acc\n            (rec (apply kons count acc\n       ",
"                 (map (lambda (v) (vector-ref v count)) vects))\n                ",
" (- count 1))))))\n\n  (define (vector-map f vec . vects)\n    (let* ((vects (cons ",
"vec vects))\n           (veclen (apply min (map vector-length vects)))\n          ",
" (new-vect (make-vector veclen)))\n      (let rec ((count 0))\n        (if (= coun",
"t veclen)\n            new-vect\n            (begin\n              (vector-set! new",
"-vect count\n                           (apply f count (map (lambda (v) (vector-r",
"ef v count))\n                                               vects)))\n           ",
"   (rec (+ 1 count)))))))\n\n  (define (vector-map! f vec . vects)\n    (let* ((vec",
"ts (cons vec vects))\n           (veclen (apply min (map vector-length vects))))\n",
"      (let rec ((count 0))\n        (if (< count veclen)\n            (begin\n     ",
"         (vector-set! vec count\n                           (apply f count (map (",
"lambda (v) (vector-ref v count))\n                                               ",
"vects)))\n              (rec (+ 1 count)))))))\n\n  (define (vector-count pred? vec",
" . vects)\n    (let* ((vects (cons vec vects))\n           (veclen (apply min (map",
" vector-length vects))))\n      (let rec ((i 0) (count 0))\n        (if (= i vecle",
"n)\n            count\n            (if (apply pred? count (map (lambda (v) (vector",
"-ref v count)) vects))\n                (rec (+ 1 i) (+ 1 count))\n               ",
" (rec (+ 1 i) count))))))\n\n  ;; # Searching\n  (define (vector-index pred? vec . ",
"vects)\n    (let* ((vects (cons vec vects))\n           (veclen (apply min (map ve",
"ctor-length vects))))\n      (let rec ((count 0))\n        (cond\n         ((= coun",
"t veclen) #f)\n         ((apply pred? (map (lambda (v) (vector-ref v count)) vect",
"s))\n          count)\n         (else (rec (+ 1 count)))))))\n\n  (define (vector-in",
"dex-right pred? vec . vects)\n    (let ((vects (cons vec vects))\n          (vecle",
"n (vector-length vec)))\n      (let rec ((count (- veclen 1)))\n        (cond\n    ",
"     ((< count 0) #f)\n         ((apply pred? (map (lambda (v) (vector-ref v coun",
"t)) vects))\n          count)\n         (else (rec (- count 1)))))))\n\n  (define (v",
"ector-skip pred? vec . vects)\n    (apply vector-index (lambda args (not (apply p",
"red? args))) vec vects))\n\n  (define (vector-skip-right pred? vec . vects)\n    (a",
"pply vector-index-right (lambda args (not (apply pred? args))) vec vects))\n\n  (d",
"efine (vector-binary-search vec value cmp)\n    (let rec ((start 0) (end (vector-",
"length vec)) (n -1))\n      (let ((count (floor/ (+ start end) 2)))\n        (if (",
"or (= start end) (= count n))\n            #f\n            (let ((comparison (cmp ",
"(vector-ref vec count) value)))\n              (cond\n               ((zero? compa",
"rison) count)\n               ((positive? comparison) (rec start count count))\n  ",
"             (else (rec count end count))))))))\n\n  (define (vector-any pred? vec",
" . vects)\n    (let* ((vects (cons vec vects))\n           (veclen (vector-length ",
"vec)))\n      (let rec ((count 0))\n        (if (= count veclen)\n            #f\n  ",
"          (or (apply pred? (map (lambda (v) (vector-ref v count)) vects))\n      ",
"          (rec (+ 1 count)))))))\n\n  (define (vector-every pred? vec . vects)\n   ",
" (let* ((vects (cons vec vects))\n           (veclen (vector-length vec)))\n      ",
"(let rec ((count 0))\n        (if (= count veclen)\n            #t\n            (an",
"d (apply pred? (map (lambda (v) (vector-ref v count)) vects))\n                 (",
"rec (+ 1 count)))))))\n\n  ;; # Mutators\n  (define (vector-swap! vec i j)\n    (let",
" ((tmp (vector-ref vec i)))\n      (vector-set! vec i (vector-ref vec j))\n      (",
"vector-set! vec j tmp)))\n\n  (define (vector-reverse! vec . rst)\n    (let ((start",
" (if (null? rst) 0 (car rst)))\n          (end (if (or (null? rst) (cdr rst))\n   ",
"                (vector-length vec)\n                   (cadr rst))))\n      (let ",
"rec ((i start) (j (- end 1)))\n        (if (< i j)\n            (begin\n           ",
"   (vector-swap! vec i j)\n              (rec (+ 1 i) (- j 1)))))))\n\n  (define (v",
"ector-reverse-copy! target tstart source . rst)\n    (let ((sstart (if (null? rst",
") 0 (car rst)))\n          (send (if (or (null? rst) (cdr rst))\n                 ",
"   (vector-length source)\n                    (cadr rst))))\n      (let rec ((i t",
"start) (j (- send 1)))\n        (if (>= j sstart)\n            (begin\n            ",
"  (vector-set! target i (vector-ref source j))\n              (rec (+ 1 i) (- j 1",
")))))))\n\n  ;; # Conversion\n  (define (reverse-vector->list vec . rst)\n    (let (",
"(start (if (null? rst) 0 (car rst)))\n          (end (if (or (null? rst) (cdr rst",
"))\n                   (vector-length vec)\n                   (cadr rst))))\n     ",
" (let rec ((i start) (acc '()))\n        (if (= i end)\n            acc\n          ",
"  (rec (+ 1 i) (cons (vector-ref vec i) acc))))))\n\n  (define (reverse-list->vect",
"or proper-list)\n    (apply vector (reverse proper-list)))\n\n  (export vector?\n   ",
"       make-vector\n          vector\n          vector-length\n          vector-ref",
"\n          vector-set!\n          vector->list\n          list->vector\n          v",
"ector-fill!\n          vector-copy!\n\n          vector-unfold\n          vector-unf",
"old-right\n          vector-reverse-copy\n          vector-concatenate\n          v",
"ector-empty?\n          vector=\n          vector-fold\n          vector-fold-right",
"\n          vector-map!\n          vector-count\n          vector-index\n          v",
"ector-index-right\n          vector-skip\n          vector-skip-right\n          ve",
"ctor-binary-search\n          vector-any\n          vector-every\n          vector-",
"swap!\n          vector-reverse!\n          vector-reverse-copy!\n          reverse",
"-vector->list\n          reverse-list->vector))\n",
"",
};

static const char piclib_src_contrib_40_srfi_srfi_60[][80] = {
"(define-library (srfi 60)\n  (import (scheme base)\n          (srfi 1))\n\n  ;; # Bi",
"twise Operations\n  (define (logand . args)\n    (letrec ((lgand\n              (la",
"mbda (x y)\n                (if (or (zero? x) (zero? y))\n                    0\n  ",
"                  (+ (* (lgand (floor/ x 2) (floor/ y 2)) 2)\n                   ",
"    (if (or (even? x) (even? y)) 0 1))))))\n      (fold lgand -1 args)))\n\n  (defi",
"ne bitwise-and logand)\n\n  (define (logior . args)\n    (letrec ((lgior\n          ",
"    (lambda (x y)\n                (cond\n                 ((= x y) x)\n           ",
"      ((zero? x) y)\n                 ((zero? y) x)\n                 (else\n      ",
"            (+ (* (lgior (truncate-quotient x 2)\n                               ",
"(truncate-quotient y 2))\n                        2)\n                     (if (an",
"d (even? x) (even? y)) 0 1)))))))\n      (fold lgior 0 args)))\n\n  (define bitwise",
"-ior logior)\n\n  (define (logxor . args)\n    (letrec ((lgxor\n              (lambd",
"a (x y)\n                (cond\n                 ((zero? x) y)\n                 ((",
"zero? y) x)\n                 (else\n                  (+ (* (lgxor (floor/ x 2) (",
"floor/ y 2)) 2)\n                     (if (even? x)\n                         (if ",
"(even? y) 0 1)\n                         (if (even? y) 1 0))))))))\n      (fold lg",
"xor 0 args)))\n\n  (define bitwise-xor logxor)\n\n  (define (lognot n)\n    (- -1 n))",
"\n\n  (define bitwise-not lognot)\n\n  (define (bitwise-if mask n0 n1)\n    (logior (",
"logand mask n0)\n            (logand (lognot mask) n1)))\n\n  (define bitwise-merge",
" bitwise-if)\n\n  (define (logtest j k)\n    (not (zero? (logand j k))))\n\n  (define",
" any-bits-set? logtest)\n\n  ;; # Integer Properties\n  (define (logcount n)\n    (l",
"etrec ((lgcnt\n              (lambda (n)\n                (if (zero? n) 0\n        ",
"            (+ (lgcnt (floor/ n 2))\n                       (if (even? n) 0 1))))",
"))\n      (if (negative? n)\n          (lgcnt (lognot n))\n          (lgcnt n))))\n\n",
"  (define bit-count logcount)\n\n  (define (integer-length n)\n    (let loop ((n n)",
" (count 0))\n      (if (zero? n)\n          count\n          (loop (floor/ n 2) (+ ",
"count 1)))))\n\n  (define (log2-binary-factors n)\n    (+ -1 (integer-length (logan",
"d n (- n)))))\n\n  (define first-set-bit log2-binary-factors)\n  \n  ;; # Bit Within",
" Word\n  (define (logbit? index n)\n    (logtest (expt 2 index) n))\n\n  (define bit",
"-set? logbit?)\n\n  (define (copy-bit index from bit)\n    (if bit\n        (logior ",
"from (expt 2 index))\n        (logand from (lognot (expt 2 index)))))\n\n\n  ;; # Fi",
"eld of Bits\n  (define (ash n count)\n    (if (negative? count)\n        (let ((k (",
"expt 2 (- count))))\n          (if (negative? n)\n              (+ -1 (truncate-qu",
"otient (+ 1 n) k))\n              (truncate-quotient n k)))\n        (* (expt 2 co",
"unt) n)))\n\n  (define arithmetic-shift ash)\n\n  (define (bit-field n start end)\n  ",
"  (logand (lognot (ash -1 (- end start)))\n            (ash n (- start))))\n\n  (de",
"fine (copy-bit-field to from start end)\n    (bitwise-if (ash (lognot (ash -1 (- ",
"end start))) start)\n                (ash from start)\n                to))\n\n  (de",
"fine (rotate-bit-field n count start end)\n    (let* ((width (- start end))\n     ",
"      (count (floor-remainder count width))\n           (mask (lognot (ash -1 wid",
"th)))\n           (zn (logand mask (ash n (- start)))))\n      (logior (ash (logio",
"r (logand mask (ash zn count))\n                           (ash zn (- count width",
")))\n                   start)\n              (logand (lognot (ash mask start)) n)",
")))\n\n  (define (reverse-bit-field n start end)\n    (letrec ((bit-reverse\n       ",
"       (lambda (k n)\n                (let loop ((m (if (negative? n) (lognot n) ",
"n))\n                           (k (- k 1))\n                           (rvs 0))\n ",
"                 (if (negative? k)\n                      (if (negative? n) (logn",
"ot rvs) rvs)\n                      (loop (ash m -1)\n                            ",
"(- k 1)\n                            (logior (ash rvs 1) (logand 1 m))))))))\n    ",
"  (let* ((width (- start end))\n             (mask (lognot (ash -1 width)))\n     ",
"        (zn (logand mask (ash n (- start)))))\n        (logior (ash (bit-reverse ",
"width zn) start)\n                (logand (lognot (ash mask start)) n)))))\n\n  ;; ",
"Bits as Booleans\n  (define (integer->list k . len)\n    (let ((len (if (null? len",
") (integer-length k) len)))\n      (let loop ((k k) (len len) (acc '()))\n        ",
"(if (or (zero? k) (zero? len))\n            acc\n            (loop (floor/ k 2) (-",
" len 1) (cons (if (even? k) #f #t) acc))))))\n\n  (define (list->integer lst)\n    ",
"(let loop ((lst lst) (acc 0))\n      (if (null? lst)\n          acc\n          (loo",
"p (cdr lst) (+ (* acc 2) (if (car lst) 1 0))))))\n\n  (define (booleans->integer .",
" args)\n    (list->integer args))\n\n  (export logand bitwise-and\n          logior ",
"bitwise-ior\n          logxor bitwise-xor\n          lognot bitwise-not\n          ",
"bitwise-if bitwise-merge\n          logtest any-bits-set?\n          logcount bit-",
"count\n          integer-length\n          log2-binary-factors first-set-bit\n     ",
"     logbit? bit-set?\n          copy-bit\n          bit-field\n          copy-bit-",
"field\n          ash arithmetic-shift\n          rotate-bit-field\n          revers",
"e-bit-field\n          integer->list\n          list->integer\n          booleans->",
"integer))\n",
"",
};

static const char piclib_src_contrib_40_srfi_srfi_95[][80] = {
"(define-library (srfi 95)\n  (import (scheme base)\n          (scheme load)\n      ",
"    (srfi 1))\n\n  (define (list-sorted? ls less?)\n    (let loop ((cur ls))\n      ",
"(if (<= (length cur) 1)\n          #t\n          (if (less? (second cur) (first cu",
"r))\n              #f\n              (loop (cdr cur))))))\n\n  (define (identity x)\n",
"    x)\n\n  (define (merge ls1 ls2 less? . opt-key)\n    (let ((key (if (null? opt-",
"key) identity (car opt-key))))\n      (let rec ((arg1 ls1) (arg2 ls2))\n        (c",
"ond ((null? arg1)\n               arg2)\n              ((null? arg2)\n             ",
"  arg1)\n              ((less? (key (car arg1)) (key (car arg2)))\n               ",
"(cons (car arg1) (rec (cdr arg1) arg2)))\n              (else\n               (con",
"s (car arg2) (rec arg1 (cdr arg2))))))))\n\n  (define (merge-sub! ls1 ls2 less? ke",
"y)\n    (let rec ((arg1 ls1) (arg2 ls2))\n      (cond ((null? arg1)\n             a",
"rg2)\n            ((null? arg2)\n             arg1)\n            ((not (less? (key ",
"(car arg2)) (key (car arg1))))\n             (set-cdr! arg1 (rec (cdr arg1) arg2)",
") arg1)\n            (else\n             (set-cdr! arg2 (rec arg1 (cdr arg2))) arg",
"2))))\n\n  (define (merge! ls1 ls2 less? . opt-key)\n    (let ((key (if (null? opt-",
"key) identity (car opt-key)))\n          (c1 (car ls1))\n          (c2 (car ls2))\n",
"          (d1 (cdr ls1))\n          (d2 (cdr ls2)))\n      (when (less? (key c2) (",
"key c1))\n        (set-car! ls1 c2)\n        (set-car! ls2 c1)\n        (set-cdr! l",
"s1 d2)\n        (set-cdr! ls2 d1))\n      (merge-sub! ls1 ls2 less? key)))\n\n  (def",
"ine (merge-sort ls less?)\n       (if (<= (length ls) 1)\n           ls\n          ",
" (let* ((n (length ls))\n                  (p (quotient n 2))\n                  (",
"as (take ls p))\n                  (bs (drop ls p))\n                  (sa (merge-",
"sort as less?))\n                  (sb (merge-sort bs less?)))\n             (merg",
"e sa sb less?))))\n\n  (define (merge-sort! ls less?)\n    (if (<= (length ls) 1) l",
"s\n        (let* ((n (length ls))\n               (p (quotient n 2))\n             ",
"  (bs (drop ls p))\n               (as (take! ls p))\n               (sa (merge-so",
"rt! as less?))\n               (sb (merge-sort! bs less?)))\n          (merge! sa ",
"sb less?))))\n\n  (export list-sorted?\n          merge\n          merge!\n          ",
"merge-sort\n          merge-sort!))\n",
"",
};

static const char piclib_src_contrib_40_srfi_srfi_106[][80] = {
"(define-library (srfi 106)\n  (import (scheme base)\n          (srfi 60)\n         ",
" (picrin optional))\n\n  ; TODO: Define assq-ref anywhere else.\n  (define (assq-re",
"f alist key . opt)\n    (cond\n      ((assq key alist) => cdr)\n      (else (if (nu",
"ll? opt) #f (car opt)))))\n\n  (define (socket-merge-flags flag . flags)\n    (if (",
"null? flags)\n      flag\n      (apply socket-merge-flags (logior (or flag 0) (or ",
"(car flags) 0))\n             (cdr flags))))\n\n  (define (socket-purge-flags base-",
"flag . flags)\n    (if (null? flags)\n      base-flag\n      (apply socket-purge-fl",
"ags (logxor (or base-flag 0) (or (car flags) 0))\n             (cdr flags))))\n\n  ",
"(define (make-client-socket node service . args)\n    (let-optionals* args ((fami",
"ly *af-inet*)\n                          (type *sock-stream*)\n                   ",
"       (flags (socket-merge-flags *ai-v4mapped*\n                                ",
"                     *ai-addrconfig*))\n                          (protocol *ippr",
"oto-ip*))\n      (make-socket node service family type flags protocol)))\n\n  (defi",
"ne (make-server-socket service . args)\n    (let-optionals* args ((family *af-ine",
"t*)\n                          (type *sock-stream*)\n                          (fl",
"ags *ai-passive*)\n                          (protocol *ipproto-ip*))\n      (make",
"-socket \"\" service family type flags protocol)))\n\n  (define %address-family `((i",
"net .   ,*af-inet*)\n                            (inet6 .  ,*af-inet6*)\n         ",
"                   (unspec . ,*af-unspec*)))\n\n  (define %socket-domain `((stream",
" .   ,*sock-stream*)\n                           (datagram . ,*sock-dgram*)))\n\n  ",
"(define %address-info `((canoname .    ,*ai-canonname*)\n                        ",
"  (numerichost . ,*ai-numerichost*)\n                          (v4mapped .    ,*a",
"i-v4mapped*)\n                          (all .         ,*ai-all*)\n               ",
"           (addrconfig .  ,*ai-addrconfig*)))\n\n  (define %ip-protocol `((ip .  ,",
"*ipproto-ip*)\n                         (tcp . ,*ipproto-tcp*)\n                  ",
"       (udp . ,*ipproto-udp*)))\n\n  (define %message-types `((none .      0)\n    ",
"                       (peek .     ,*msg-peek*)\n                           (oob ",
".      ,*msg-oob*)\n                           (wait-all . ,*msg-waitall*)))\n\n  (",
"define-syntax address-family\n    (syntax-rules ()\n      ((_ name)\n       (assq-r",
"ef %address-family 'name))))\n\n  (define-syntax socket-domain\n    (syntax-rules (",
")\n      ((_ name)\n       (assq-ref %socket-domain 'name))))\n\n  (define-syntax ad",
"dress-info\n    (syntax-rules ()\n      ((_ names ...)\n       (apply socket-merge-",
"flags\n              (map (lambda (name) (assq-ref %address-info name))\n         ",
"          '(names ...))))))\n\n  (define-syntax ip-protocol\n    (syntax-rules ()\n ",
"     ((_ name)\n       (assq-ref %ip-protocol 'name))))\n\n  (define-syntax message",
"-type\n    (syntax-rules ()\n      ((_ names ...)\n       (apply socket-merge-flags",
"\n              (map (lambda (name) (assq-ref %message-types name))\n             ",
"      '(names ...))))))\n\n  (define (%shutdown-method names)\n    (define (state->",
"method state)\n      (case state\n        ((read) *shut-rd*)\n        ((write) *shu",
"t-wr*)\n        ((read-write) *shut-rdwr*)\n        (else #f)))\n    (let loop ((na",
"mes names)\n               (state 'none))\n      (cond\n        ((null? names) (sta",
"te->method state))\n        ((eq? (car names) 'read)\n         (loop (cdr names)\n ",
"              (cond\n                 ((eq? state 'none) 'read)\n                 ",
"((eq? state 'write) 'read-write)\n                 (else state))))\n        ((eq? ",
"(car names) 'write)\n         (loop (cdr names)\n               (cond\n            ",
"     ((eq? state 'none) 'write)\n                 ((eq? state 'read) 'read-write)",
"\n                 (else state))))\n        (else (loop (cdr names) 'other)))))\n\n ",
" (define-syntax shutdown-method\n    (syntax-rules ()\n      ((_ names ...)\n      ",
" (%shutdown-method '(names ...)))))\n\n  ;; Constructors and predicate\n  (export m",
"ake-client-socket\n          make-server-socket\n          socket?)\n\n  ;; Socket o",
"perations\n  (export socket-accept\n          socket-send\n          socket-recv\n  ",
"        socket-shutdown\n          socket-close)\n\n  ;; Port conversion\n  (export ",
"socket-input-port\n          socket-output-port)\n\n  ;; Control feature\n  (export ",
"call-with-socket)\n\n  ;; Flag operations\n  (export address-family\n          socke",
"t-domain\n          address-info\n          ip-protocol\n          message-type\n   ",
"       shutdown-method\n          socket-merge-flags\n          socket-purge-flags",
")\n\n  ;; Constant values\n  (export *af-inet*\n          *af-inet6*\n          *af-u",
"nspec*)\n  (export *sock-stream*\n          *sock-dgram*)\n  (export *ai-canonname*",
"\n          *ai-numerichost*\n          *ai-v4mapped*\n          *ai-all*\n         ",
" *ai-addrconfig*)\n  (export *ipproto-ip*\n          *ipproto-tcp*\n          *ippr",
"oto-udp*)\n  (export *msg-peek*\n          *msg-oob*\n          *msg-waitall*)\n  (e",
"xport *shut-rd*\n          *shut-wr*\n          *shut-rdwr*))\n",
"",
};

static const char piclib_src_contrib_40_srfi_srfi_111[][80] = {
"(define-library (srfi 111)\n  (import (scheme base))\n\n  (define-record-type <box>",
"\n    (box value)\n    box?\n    (value unbox set-box!))\n\n  (export box box?\n      ",
"    unbox set-box!))\n",
"",
};

static const char piclib_src_contrib_50_class_piclib_picrin_class[][80] = {
"(define-library (picrin class)\n  (import (scheme base))\n\n  (define-record-type c",
"lass-type\n      (make-class membership)\n      class?\n    (membership class-membe",
"rship))\n\n  (define-syntax define-class\n    (syntax-rules ()\n      ((define-class",
" name membership)\n       (define name (make-class membership)))))\n\n  (define (in",
"stance? obj class)\n    ((class-membership class) obj))\n\n  (define-class <class> ",
"class?)\n\n  (define-class <any> (lambda (x) #t))\n  (define-class <list> list?)\n  ",
"(define-class <procedure> procedure?)\n  (define-class <number> number?)\n  (defin",
"e-class <boolean> boolean?)\n  (define-class <string> string?)\n\n  (export make-cl",
"ass\n          instance?\n          define-class\n          <class>\n          <any>",
"\n          <list>\n          <procedure>\n          <number>\n          <boolean>\n ",
"         <string>))\n",
"",
};

static const char piclib_src_contrib_50_destructuring_bind_lambda[][80] = {
"(define-library (picrin destructuring-bind)\n  (import (picrin base)\n          (p",
"icrin macro))\n\n  (define-syntax (destructuring-bind formal value . body)\n    (co",
"nd\n     ((identifier? formal)\n      #`(let ((#,formal #,value))\n          #,@bod",
"y))\n     ((pair? formal)\n      #`(let ((value #,value))\n          (destructuring",
"-bind #,(car formal) (car value)\n            (destructuring-bind #,(cdr formal) ",
"(cdr value)\n              #,@body))))\n     ((vector? formal)\n      ;; TODO\n     ",
" (error \"fixme\"))\n     (else\n      #`(if (equal? #,value '#,formal)\n            ",
"(begin\n              #,@body)\n            (error \"match failure\" #,value '#,form",
"al)))))\n\n  (export destructuring-bind))\n",
"",
};

static const char piclib_src_contrib_50_for_piclib_for[][80] = {
"(define-library (picrin control list)\n  (import (scheme base)\n          (picrin ",
"control))\n\n  (define unit list)\n\n  (define (bind m f)\n    (apply append (map f m",
")))\n\n  (define-syntax reify\n    (syntax-rules ()\n      ((_ expr)\n       (reset (",
"unit expr)))))\n\n  (define (reflect m)\n    (shift k (bind m k)))\n\n  (define zero ",
"'())\n\n  (define plus append)\n\n  (export unit\n          bind\n          zero\n     ",
"     plus\n          reify\n          reflect\n          (rename reify for)\n       ",
"   (rename reflect in)\n          (rename unit yield)))\n",
"",
};

static const char piclib_src_contrib_50_option_option[][80] = {
"(define-library (picrin control option)\n  (import (scheme base)\n          (picri",
"n control)\n          (picrin procedure))\n\n  (define unit identity)\n\n  (define (b",
"ind m f)\n    (and m (f m)))\n\n  (define-syntax reify\n    (syntax-rules ()\n      (",
"(_ expr)\n       (reset (unit expr)))))\n\n  (define (reflect m)\n    (shift k (bind",
" m k)))\n\n  (export unit\n          bind\n          reify\n          reflect))\n",
"",
};

static const char piclib_src_contrib_60_logic_logic[][80] = {
"(define-library (picrin logic)\n  (import (scheme base)\n          (picrin control",
"))\n  (export call/fresh\n          disj\n          conj\n          is\n          run",
"-goal\n          run-goal*\n          zero\n          plus\n          unit\n         ",
" bind\n          reify\n          reflect)\n\n  (define (assp p alist)\n    (if (null",
"? alist)\n        #f\n        (if (p (caar alist))\n            (car alist)\n       ",
"     (assp p (cdr alist)))))\n\n  (define (force* $)\n    (if (procedure? $) (force",
"* ($)) $))\n\n  ;; fundation\n\n  (define (var c) (vector c))\n  (define (var? x) (ve",
"ctor? x))\n  (define (var=? x1 x2) (= (vector-ref x1 0) (vector-ref x2 0)))\n\n  (d",
"efine (subst u s)\n    (let ((pr (and (var? u) (assp (lambda (v) (var=? u v)) s))",
"))\n      (if pr (subst (cdr pr) s) u)))\n\n  (define (subst* v s)\n    (let ((v (su",
"bst v s)))\n      (cond\n       ((var? v) v)\n       ((pair? v) (cons (subst* (car ",
"v) s)\n                        (subst* (cdr v) s)))\n       (else v))))\n\n  (define",
" (ext-s x v s) `((,x . ,v) . ,s))\n\n  (define (unify u v s)\n    (let ((u (subst u",
" s)) (v (subst v s)))\n      (cond\n       ((and (var? u) (var? v) (var=? u v)) s)",
"\n       ((var? u) (ext-s u v s))\n       ((var? v) (ext-s v u s))\n       ((and (p",
"air? u) (pair? v))\n        (let ((s (unify (car u) (car v) s)))\n          (and s",
" (unify (cdr u) (cdr v) s))))\n       (else (and (eqv? u v) s)))))\n\n  ;; klist mo",
"nad\n\n  (define zero '())\n  (define (plus $1 $2)\n    (cond\n     ((null? $1) $2)\n ",
"    ((procedure? $1) (lambda () (plus $2 ($1))))\n     ((pair? $1) (cons (car $1)",
" (plus (cdr $1) $2)))))\n\n  (define (unit s/c) (list s/c))\n  (define (bind $ g)\n ",
"   (cond\n     ((null? $) zero)\n     ((procedure? $) (lambda () (bind ($) g)))\n  ",
"   ((pair? $) (plus (g (car $)) (bind (cdr $) g)))))\n\n  (define-syntax reify\n   ",
" (syntax-rules ()\n      ((_ expr)\n       (reset (unit expr)))))\n\n  (define (refl",
"ect m)\n    (shift k (bind m k)))\n\n  ;; goal constructors\n\n  (define (call/fresh ",
"f)\n    (lambda (s/c)\n      (let ((s (car s/c)) (c (cdr s/c)))\n        ((f (var c",
")) `(,s . ,(+ c 1))))))\n\n  (define (disj g1 g2) (lambda (s/c) (plus (g1 s/c) (g2",
" s/c))))\n  (define (conj g1 g2) (lambda (s/c) (bind (g1 s/c) g2)))\n\n  (define (i",
"s u v)\n    (lambda (s/c)\n      (let ((s (unify u v (car s/c))))\n        (if s (u",
"nit `(,s . ,(cdr s/c))) zero))))\n\n  ;; goal runner\n\n  (define initial-state '(()",
" . 0))\n\n  (define (run-goal n g)\n    (map reify-1st (take n (g initial-state))))",
"\n\n  (define (run-goal* g)\n    (map reify-1st (take* (g initial-state))))\n\n  (def",
"ine (take n $)\n    (if (zero? n) '()\n        (let (($ (force* $)))\n          (if",
" (null? $) '() (cons (car $) (take (- n 1) (cdr $)))))))\n\n  (define (take* $)\n  ",
"  (let (($ (force* $)))\n      (if (null? $) '() (cons (car $) (take* (cdr $)))))",
")\n\n  (define (reify-1st s/c)\n    (let ((v (subst* (var 0) (car s/c))))\n      (su",
"bst* v (reify-s v '()))))\n\n  (define (reify-s v s)\n    (let ((v (subst v s)))\n  ",
"    (cond\n       ((var? v)\n        (let  ((n (reify-name (length s))))\n         ",
" (cons `(,v . ,n) s)))\n       ((pair? v) (reify-s (cdr v) (reify-s (car v) s)))\n",
"       (else s))))\n\n  (define (reify-name n)\n    (string->symbol\n     (string-ap",
"pend \"_\" \".\" (number->string n)))))\n",
"",
};

static const char piclib_src_contrib_60_peg_picrin_parser[][80] = {
"(define-library (picrin parser)\n  (import (scheme base)\n          (picrin contro",
"l)\n          (picrin procedure))\n  (export parse\n          ;; monadic\n          ",
"reify\n          reflect\n          bind\n          unit\n          zero\n          p",
"lus\n          fapply\n          ;; look ahead\n          with\n          without\n  ",
"        ;; eta\n          lazy\n          ;; aux\n          choice\n          option",
"al\n          many\n          between)\n\n  ;; type Parser i r = i -> Maybe (r, i)\n\n",
"  (define (parse rule input)\n    (rule input))\n\n  ;; monadic operators\n\n  (defin",
"e-syntax reify\n    (syntax-rules ()\n      ((_ expr)\n       (reset (unit expr))))",
")\n\n  (define (reflect x)\n    (shift k (bind x k)))\n\n  (define (bind m f)\n    (la",
"mbda (i)\n      (let ((x (m i)))\n        (and x ((f (car x)) (cdr x))))))\n\n  (def",
"ine (unit x)\n    (lambda (i)\n      `(,x . ,i)))\n\n  (define zero\n    (lambda (i) ",
"#f))\n\n  (define (plus a b)\n    (lambda (i)\n      (or (a i) (b i))))\n\n  (define (",
"fapply f . args)\n    (reify\n     (let loop ((args args) (ps '()))\n       (if (nu",
"ll? args)\n           (apply f (reverse ps))\n           (loop (cdr args) (cons (r",
"eflect (car args)) ps))))))\n\n  ;; look ahead\n\n  (define (with a)\n    (lambda (i)",
"\n      (and (a i) `(#f . ,i))))\n\n  (define (without a)\n    (lambda (i)\n      (an",
"d (not (a i)) `(#f . ,i))))\n\n  ;; eta conversion\n\n  (define-syntax lazy\n    (syn",
"tax-rules ()\n      ((_ expr)\n       (lambda (i) (expr i)))))\n\n  ;; aux\n\n  (defin",
"e (choice . xs)\n    (if (null? xs)\n        zero\n        (plus (car xs) (apply ch",
"oice (cdr xs)))))\n\n  (define (optional a)\n    (choice a (unit #f)))\n\n  (define (",
"many a)\n    (lazy\n     (choice\n      (reify\n       (let* ((a (reflect a))\n      ",
"        (b (reflect (many a))))\n         (cons a b)))\n      null)))\n\n  (define (",
"between l x r)\n    (fapply (>> list cadr) l x r)))\n",
"",
};

static const char piclib_src_contrib_60_peg_picrin_parser_string[][80] = {
"(define-library (picrin parser string)\n  (import (except (scheme base) string)\n ",
"         (picrin parser))\n  (export string\n          any-char\n          eof\n    ",
"      parse-string)\n\n  ;; string stream parser\n\n  (define (string str)\n    (lamb",
"da (i)\n      (let ((i (car i)) (input (cdr i)))\n        (let ((j (min (+ i (stri",
"ng-length str)) (string-length input))))\n          (and (equal? str (string-copy",
" input i j))\n               `(,str . ,(cons j input)))))))\n\n  (define any-char\n ",
"   (lambda (i)\n      (let ((i (car i)) (input (cdr i)))\n        (and (< i (strin",
"g-length input))\n             `(,(string-ref input i) . ,(cons (+ i 1) input))))",
"))\n\n  (define eof\n    (without any-char))\n\n  (define (parse-string rule input)\n ",
"   (parse rule (cons 0 input))))\n",
"",
};

static const char piclib_src_contrib_60_repl_repl[][80] = {
"(define-library (picrin repl)\n  (import (scheme base)\n          (scheme read)\n  ",
"        (scheme write)\n          (scheme eval)\n          (picrin base))\n\n  (cond",
"-expand\n   ((library (picrin readline))\n    (import (picrin readline)\n          ",
"  (picrin readline history)))\n   (else\n    (begin\n      (define (readline str)\n ",
"       (when (tty?)\n          (display str)\n          (flush-output-port))\n     ",
"   (read-line))\n      (define (add-history str)\n        #f))))\n\n  (define (init-",
"env)\n    (eval\n     '(import (scheme base)\n              (scheme load)\n         ",
"     (scheme process-context)\n              (scheme read)\n              (scheme ",
"write)\n              (scheme file)\n              (scheme inexact)\n              ",
"(scheme cxr)\n              (scheme lazy)\n              (scheme time)\n           ",
"   (scheme eval)\n              (scheme r5rs)\n              (picrin macro))\n     ",
"\"picrin.user\"))\n\n  (define (repeat x)\n    (let ((p (list x)))\n      (set-cdr! p ",
"p)\n      p))\n\n  (define (join xs delim)\n    (cdr (apply append (map list (repeat",
" delim) xs))))\n\n  (define (string-join strings delim)\n    (apply string-append (",
"join strings delim)))\n\n  (define (->string x)\n    (call-with-port (open-output-s",
"tring)\n      (lambda (port)\n        (write x port)\n        (get-output-string po",
"rt))))\n\n  (define (print-error-object e)\n    (define type (error-object-type e))",
"\n    (unless (eq? type '||)\n      (display type)\n      (display \"-\"))\n    (displ",
"ay \"error: \")\n    (display (error-object-message e))\n    (display \".\")\n    (defi",
"ne irritants (error-object-irritants e))\n    (unless (null? irritants)\n      (di",
"splay \" (irritants: \")\n      (display (string-join (map ->string irritants) \", \"",
"))\n      (display \")\"))\n    (newline))\n\n  (define (repl)\n    (init-env)\n    (let",
" loop ((buf \"\"))\n      (let ((line (readline (if (equal? buf \"\") \"> \" \"\"))))\n   ",
"     (if (eof-object? line)\n            (newline)                   ; exit\n     ",
"       (let ((str (string-append buf line \"\\n\")))\n              (add-history lin",
"e)\n              (call/cc\n               (lambda (exit)\n                 (with-e",
"xception-handler\n                  (lambda (condition)\n                    (if (",
"error-object? condition)\n                        (unless (equal? (error-object-m",
"essage condition) \"unexpected EOF\")\n                          (print-error-objec",
"t condition)\n                          (set! str \"\"))\n                        (b",
"egin\n                          (display \"raise: \")\n                          (wr",
"ite condition)\n                          (newline)\n                          (se",
"t! str \"\")))\n                    (exit))\n                  (lambda ()\n          ",
"          (call-with-port (open-input-string str)\n                      (lambda ",
"(port)\n                        (let next ((expr (read port)))\n                  ",
"        (unless (eof-object? expr)\n                            (write (eval expr",
" \"picrin.user\"))\n                            (newline)\n                         ",
"   (set! str \"\")\n                            (next (read port))))))))))\n        ",
"      (loop str))))))\n\n  (export repl))\n\n",
"",
};

static const char piclib_src_contrib_70_main_main[][80] = {
"(define-library (picrin main)\n  (import (scheme base)\n          (scheme read)\n  ",
"        (scheme write)\n          (scheme process-context)\n          (scheme load",
")\n          (scheme eval)\n          (picrin base)\n          (picrin repl))\n\n  (d",
"efine (print-help)\n    (display \"picrin scheme\\n\")\n    (display \"\\n\")\n    (displ",
"ay \"Usage: picrin [options] [file]\\n\")\n    (display \"\\n\")\n    (display \"Options:",
"\\n\")\n    (display \"  -e [program]		run one liner script\\n\")\n    (display \"  -l [",
"file]		load the file then enter repl\\n\")\n    (display \"  -h or --help		show this",
" help\\n\"))\n\n  (define (getopt)\n    (let ((args (cdr (command-line))))\n      (if ",
"(null? args)\n          (values 'repl #f)\n          (case (string->symbol (car ar",
"gs))\n            ((-h --help)\n             (print-help)\n             (exit 1))\n ",
"           ((-e)\n             (values 'line (cadr args)))\n            ((-l)\n    ",
"         (values 'load (cadr args)))\n            (else\n             (values 'fil",
"e (car args)))))))\n\n  (define (exec-file filename)\n    (load filename))\n\n  (defi",
"ne (exec-line str)\n    (call-with-port (open-input-string str)\n      (lambda (in",
")\n        (let loop ((expr (read in)))\n          (unless (eof-object? expr)\n    ",
"        (eval expr (find-library \"picrin.user\"))\n            (loop (read in)))))",
"))\n\n  (define (main)\n    (call-with-values getopt\n      (lambda (type dat)\n     ",
"   (case type\n          ((repl) (repl))\n          ((load) (load dat) (repl))\n   ",
"       ((line) (exec-line dat))\n          ((file) (exec-file dat))))))\n\n  (expor",
"t main))\n",
"",
};

static const char piclib_src_contrib_80_protocol_piclib_picrin_protocol[][80] = {
"(define-library (picrin protocol)\n  (import (scheme base)\n          (srfi 1))\n\n ",
" (import (picrin class))\n\n  (define method-table\n    '())\n\n  (define (applicativ",
"e? args types)\n    (cond\n     ((and (null? args) (null? types))\n      #true)\n   ",
"  ((and (pair? args) (pair? types))\n      (and (instance? (car args) (car types)",
") (applicative? (cdr args) (cdr types))))\n     (else\n      #false)))\n\n  (define ",
"(find-generic generic)\n    (or (assq generic method-table)\n        (error \"no me",
"thod alist found\")))\n\n  (define (find-method generic args)\n    (let ((methods (c",
"dr (find-generic generic))))\n      (let ((m (filter (lambda (x) (applicative? ar",
"gs (cdr x))) methods)))\n        (if (null? m)\n            #f\n            (car (c",
"ar m))))))\n\n  (define (add-generic generic)\n    (set! method-table (cons (cons g",
"eneric '()) method-table)))\n\n  (define (add-method generic method types)\n    (le",
"t ((r (find-generic generic)))\n      (set-cdr! r (cons (cons method types) (cdr ",
"r)))))\n\n  (define (add-methods methods prototypes)\n    (for-each\n     (lambda (m",
"ethod prototype)\n       (add-method (car prototype) method (cdr prototype)))\n   ",
"  methods\n     prototypes))\n\n  (define make-generic\n    (lambda ()\n      (letrec",
" ((self (lambda args\n                       (let ((m (find-method self args)))\n ",
"                        (if m\n                             (apply m args)\n      ",
"                       (error \"method not found\"))))))\n        (add-generic self",
")\n        self)))\n\n  (define-syntax define-protocol\n    (syntax-rules ()\n      (",
"(define-protocol (name type ...) (method arg ...) ...)\n       (begin\n         (d",
"efine method\n           (make-generic))\n         ...\n         (define name\n     ",
"      (lambda (type ...)\n             (lambda methods\n               (add-method",
"s methods (list (list method arg ...) ...)))))))))\n\n  (define-syntax define-inst",
"ance\n    (syntax-rules ()\n      ((define-instance (name arg ...) method ...)\n   ",
"    ((name arg ...) method ...))))\n\n  (export define-protocol\n          define-i",
"nstance))\n",
"",
};

static const char piclib_src_contrib_90_array_array[][80] = {
"(define-library (picrin array)\n  (import (scheme base))\n\n  (define-record-type <",
"array>\n    (create-array data size head tail)\n    array?\n    (data array-data se",
"t-array-data!)\n    (size array-size set-array-size!)\n    (head array-head set-ar",
"ray-head!)\n    (tail array-tail set-array-tail!))\n\n  (define (translate ary i)\n ",
"   (floor-remainder i (array-size ary)))\n\n  (define (array-length ary)\n    (let ",
"((size (- (array-tail ary) (array-head ary))))\n     (translate ary size)))\n\n  (d",
"efine (array-rotate! ary)\n    (when (< (array-tail ary) (array-head ary))\n      ",
"(let ((xs (vector-copy (array-data ary) 0 (array-head ary)))\n            (ys (ve",
"ctor-copy (array-data ary) (array-head ary))))\n        (set-array-data! ary (vec",
"tor-append ys xs))\n        (set-array-tail! ary (array-length ary))\n        (set",
"-array-head! ary 0))))\n\n  (define (array-reserve! ary size)\n    (set! size (+ si",
"ze 1))              ; capa == size - 1\n    (when (< (array-size ary) size)\n     ",
" (array-rotate! ary)\n      (set-array-data! ary (vector-append\n                 ",
"           (array-data ary)\n                            (make-vector (- size (ar",
"ray-size ary)))))\n      (set-array-size! ary size)))\n\n  (define (make-array . re",
"st)\n    (if (null? rest)\n        (make-array 0)\n        (let ((capacity (car res",
"t))\n              (ary (create-array (make-vector 0) 0 0 0)))\n          (array-r",
"eserve! ary capacity)\n          ary)))\n\n  (define (array-ref ary i)\n    (let ((d",
"ata (array-data ary)))\n      (vector-ref data (translate ary (+ (array-head ary)",
" i)))))\n\n  (define (array-set! ary i obj)\n    (let ((data (array-data ary)))\n   ",
"   (vector-set! data (translate ary (+ (array-head ary) i)) obj)))\n\n  (define (a",
"rray-push! ary obj)\n    (array-reserve! ary (+ (array-length ary) 1))\n    (array",
"-set! ary (array-length ary) obj)\n    (set-array-tail! ary (translate ary (+ (ar",
"ray-tail ary) 1))))\n\n  (define (array-pop! ary)\n    (set-array-tail! ary (transl",
"ate ary (- (array-tail ary) 1)))\n    (array-ref ary (array-length ary)))\n\n  (def",
"ine (array-shift! ary)\n    (set-array-head! ary (translate ary (+ (array-head ar",
"y) 1)))\n    (array-ref ary -1))\n\n  (define (array-unshift! ary obj)\n    (array-r",
"eserve! ary (+ (array-length ary) 1))\n    (array-set! ary -1 obj)\n    (set-array",
"-head! ary (translate ary (- (array-head ary) 1))))\n\n  (define (array->list ary)",
"\n    (do ((i 0 (+ i 1))\n         (x '() (cons (array-ref ary i) x)))\n        ((=",
" i (array-length ary))\n         (reverse x))))\n\n  (define (list->array list)\n   ",
" (let ((ary (make-array)))\n      (for-each (lambda (x) (array-push! ary x)) list",
")\n      ary))\n\n  (define (array . objs)\n    (list->array objs))\n\n  (define (arra",
"y-map proc ary)\n    (list->array (map proc (array->list ary))))\n\n  (define (arra",
"y-for-each proc ary)\n    (for-each proc (array->list ary)))\n\n  (export make-arra",
"y\n          array\n          array?\n          array-length\n          array-ref\n  ",
"        array-set!\n          array-push!\n          array-pop!\n          array-sh",
"ift!\n          array-unshift!\n          array-map\n          array-for-each\n     ",
"     array->list\n          list->array))\n",
"",
};

void
pic_load_piclib(pic_state *pic)
{
  pic_value e;

  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_10_attribute_attr[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading 10.attribute/attr.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_10_macro_macro[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading 10.macro/macro.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_20_r7rs_scheme_base[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading scheme/base.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_20_r7rs_scheme_cxr[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading scheme/cxr.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_20_r7rs_scheme_read[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading scheme/read.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_20_r7rs_scheme_write[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading scheme/write.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_20_r7rs_scheme_file[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading scheme/file.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_20_r7rs_scheme_case_lambda[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading scheme/case-lambda.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_20_r7rs_scheme_lazy[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading scheme/lazy.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_20_r7rs_scheme_eval[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading scheme/eval.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_20_r7rs_scheme_inexact[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading scheme/inexact.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_20_r7rs_scheme_load[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading scheme/load.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_20_r7rs_scheme_process_context[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading scheme/process-context.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_20_r7rs_scheme_time[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading scheme/time.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_20_r7rs_scheme_r5rs[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading scheme/r5rs.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_30_optional_piclib_optional[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading piclib/optional.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_30_partcont_piclib_partcont[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading piclib/partcont.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_30_pretty_print_pretty_print[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading 30.pretty-print/pretty-print.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_30_test_test[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading 30.test/test.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_40_procedure_procedure[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading 40.procedure/procedure.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_40_srfi_srfi_0[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading srfi/0.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_40_srfi_srfi_1[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading srfi/1.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_40_srfi_srfi_8[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading srfi/8.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_40_srfi_srfi_17[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading srfi/17.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_40_srfi_srfi_26[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading srfi/26.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_40_srfi_srfi_43[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading srfi/43.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_40_srfi_srfi_60[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading srfi/60.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_40_srfi_srfi_95[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading srfi/95.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_40_srfi_srfi_106[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading srfi/106.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_40_srfi_srfi_111[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading srfi/111.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_50_class_piclib_picrin_class[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading picrin/class.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_50_destructuring_bind_lambda[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading 50.destructuring-bind/lambda.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_50_for_piclib_for[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading piclib/for.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_50_option_option[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading 50.option/option.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_60_logic_logic[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading 60.logic/logic.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_60_peg_picrin_parser[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading picrin/parser.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_60_peg_picrin_parser_string[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading parser/string.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_60_repl_repl[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading 60.repl/repl.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_70_main_main[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading 70.main/main.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_80_protocol_piclib_picrin_protocol[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading picrin/protocol.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
  pic_try {
    pic_load_cstr(pic, &piclib_src_contrib_90_array_array[0][0]);
  }
  pic_catch(e) {
    /* error! */
    pic_fputs(pic, "fatal error: failure in loading 90.array/array.scm\n", pic_stderr(pic));
    pic_raise(pic, e);
  }
}
